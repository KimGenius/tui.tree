tui.util.defineNamespace("fedoc.content", {});
fedoc.content["features_draggable.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>'use strict';\nvar util = require('./../util');\n\nvar defaultOptions = {\n        useHelper: true,\n        helperPos: {\n            y: 2,\n            x: 5\n        },\n        autoOpenDelay: 1500,\n        isSortable: false,\n        hoverClassName: 'tui-tree-hover',\n        lineClassName: 'tui-tree-line',\n        lineBoundary: {\n            top: 2,\n            bottom: 2\n        }\n    },\n    rejectedTagNames = [\n        'INPUT',\n        'BUTTON',\n        'UL'\n    ],\n    API_LIST = [],\n    inArray = tui.util.inArray;\n\n/**\n * Set the tree draggable\n * @class Draggable\n * @constructor\n * @param {Tree} tree - Tree\n * @param {Object} options - Options\n *  @param {boolean} options.useHelper - Using helper flag\n *  @param {{x: number, y:number}} options.helperPos - Helper position\n *  @param {Array.&lt;string>} options.rejectedTagNames - No draggable tag names\n *  @param {Array.&lt;string>} options.rejectedClassNames - No draggable class names\n *  @param {number} options.autoOpenDelay - Delay time while dragging to be opened\n *  @param {boolean} options.isSortable - Flag of whether using sortable dragging\n *  @param {string} options.hoverClassName - Class name for hovered node\n *  @param {string} options.lineClassName - Class name for moving position line\n *  @param {{top: number, bottom: number}} options.lineBoundary - Boundary value for visible moving line\n */\nvar Draggable = tui.util.defineClass(/** @lends Draggable.prototype */{/*eslint-disable*/\n    static: {\n        /**\n         * @static\n         * @memberOf Draggable\n         * @returns {Array.&lt;string>} API list of Draggable\n         */\n        getAPIList: function() {\n            return API_LIST.slice();\n        }\n    },\n\n    init: function(tree, options) { /*eslint-enable*/\n        this.tree = tree;\n        this.setMembers(options);\n        this.attachMousedown();\n    },\n\n    /**\n     * Set members of this module\n     * @param {Object} options - input options\n     */\n    setMembers: function(options) {\n        var helperElement = document.createElement('span'),\n            style = helperElement.style;\n        options = tui.util.extend({}, defaultOptions, options);\n\n        this.useHelper = options.useHelper;\n        this.helperPos = options.helperPos;\n        this.rejectedTagNames = rejectedTagNames.concat(options.rejectedTagNames);\n        this.rejectedClassNames = [].concat(options.rejectedClassNames);\n        this.helperElement = helperElement;\n        this.userSelectPropertyKey = null;\n        this.userSelectPropertyValue = null;\n        this.currentNodeId = null;\n        this.autoOpenDelay = options.autoOpenDelay;\n        this.isSortable = options.isSortable;\n        this.hoverClassName = options.hoverClassName;\n        this.lineClassName = options.lineClassName;\n        this.lineBoundary = options.lineBoundary;\n        this.hoveredElement = null;\n        this.movingLineType = null;\n        this.timer = null;\n\n        style.position = 'absolute';\n        style.display = 'none';\n        this.tree.rootElement.parentNode.appendChild(helperElement);\n\n        if (this.isSortable) {\n            this._setMovingLine();\n        }\n    },\n\n    /**\n     * Attach mouse down event\n     */\n    attachMousedown: function() {\n        this.preventTextSelection();\n        this.tree.on('mousedown', this.onMousedown, this);\n    },\n\n    /**\n     * Prevent text-selection\n     */\n    preventTextSelection: function() {\n        var tree = this.tree,\n            style = tree.rootElement.style,\n            selectKey = util.testProp(\n                ['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']\n            );\n\n        util.addEventListener(tree.rootElement, 'selectstart', util.preventDefault);\n\n        this.userSelectPropertyKey = selectKey;\n        this.userSelectPropertyValue = style[selectKey];\n        style[selectKey] = 'none';\n    },\n\n    /**\n     * Return whether the target element is in rejectedTagNames or in rejectedClassNames\n     * @param {HTMLElement} target - Target element\n     * @returns {boolean} Whether the target is not draggable or draggable\n     */\n    isNotDraggable: function(target) {\n        var tagName = target.tagName.toUpperCase(),\n            classNames = util.getClass(target).split(/\\s+/),\n            result;\n\n        if (inArray(tagName, this.rejectedTagNames) !== -1) {\n            return true;\n        }\n\n        tui.util.forEach(classNames, function(className) {\n            result = inArray(className, this.rejectedClassNames) !== -1;\n\n            return !result;\n        }, this);\n\n        return result;\n    },\n\n    /**\n     * Event handler - mousedown\n     * @param {MouseEvent} event - Mouse event\n     */\n    onMousedown: function(event) {\n        var target = util.getTarget(event),\n            tree = this.tree,\n            nodeId;\n\n        if (util.isRightButton(event) || this.isNotDraggable(target)) {\n            return;\n        }\n        util.preventDefault(event);\n\n        target = util.getTarget(event);\n        nodeId = tree.getNodeIdFromElement(target);\n        this.currentNodeId = nodeId;\n        if (this.useHelper) {\n            this.setHelper(target.innerText || target.textContent);\n        }\n\n        tree.on({\n            mousemove: this.onMousemove,\n            mouseup: this.onMouseup\n        }, this);\n    },\n\n    /**\n     * Event handler - mousemove\n     * @param {MouseEvent} event - Mouse event\n     */\n    onMousemove: function(event) {\n        var tree = this.tree;\n        var helperEl = this.helperElement;\n        var mousePos = util.getMousePos(event);\n        var target = util.getTarget(event);\n        var nodeId = tree.getNodeIdFromElement(target);\n        var pos = tree.rootElement.getBoundingClientRect();\n\n        if (!this.useHelper) {\n            return;\n        }\n\n        helperEl.style.top = mousePos.y - pos.top + this.helperPos.y + 'px';\n        helperEl.style.left = mousePos.x - pos.left + this.helperPos.x + 'px';\n        helperEl.style.display = '';\n\n        if (nodeId) {\n            this._applyMoveAction(nodeId, mousePos);\n        }\n    },\n\n    /**\n     * Event handler - mouseup\n     * @param {MouseEvent} event - Mouse event\n     */\n    onMouseup: function(event) {\n        var tree = this.tree;\n        var target = util.getTarget(event);\n        var nodeId = tree.getNodeIdFromElement(target);\n        var index = -1;\n\n        if (this.isSortable) {\n            this.lineElement.style.visibility = 'hidden';\n\n            if (nodeId &amp;&amp; this.movingLineType) {\n                index = this._getIndexForInserting(nodeId);\n                nodeId = tree.getParentId(nodeId);\n            }\n        }\n\n        this.helperElement.style.display = 'none';\n        tree.move(this.currentNodeId, nodeId, index);\n        this.currentNodeId = null;\n        this.movingLineType = null;\n\n        tree.off(this, 'mousemove');\n        tree.off(this, 'mouseup');\n    },\n\n    /**\n     * Restore text-selection\n     */\n    restoreTextSelection: function() {\n        var tree = this.tree;\n        util.removeEventListener(tree.rootElement, 'selectstart', util.preventDefault);\n        if (this.userSelectPropertyKey) {\n            tree.rootElement.style[this.userSelectPropertyKey] = this.userSelectPropertyValue;\n        }\n    },\n\n    /**\n     * Set helper contents\n     * @param {string} text - Helper contents\n     */\n    setHelper: function(text) {\n        this.helperElement.innerHTML = text;\n    },\n\n    /**\n     * Detach mousedown event\n     */\n    detachMousedown: function() {\n        this.tree.off(this);\n    },\n\n    /**\n     * Disable this module\n     */\n    destroy: function() {\n        this.restoreTextSelection();\n        this.detachMousedown();\n    },\n\n    /**\n     * Set moving line element\n     */\n    _setMovingLine: function() {\n        var lineElement = document.createElement('div');\n        var lineStyle = lineElement.style;\n\n        lineStyle.position = 'absolute';\n        lineStyle.visibility = 'hidden';\n\n        lineElement.className = this.lineClassName;\n\n        this.tree.rootElement.parentNode.appendChild(lineElement);\n\n        this.lineElement = lineElement;\n    },\n\n    /**\n     * Apply move action that are delay effect and sortable moving node\n     * @param {strig} nodeId - Selected tree node id\n     * @param {object} mousePos - Current mouse position\n     */\n    _applyMoveAction: function(nodeId, mousePos) {\n        var currentElement = document.getElementById(nodeId);\n        var targetPos = currentElement.getBoundingClientRect();\n        var hasClass = util.hasClass(currentElement, this.hoverClassName);\n        var isContain = this._isContain(targetPos, mousePos);\n        var boundaryType;\n\n        if (!this.hoveredElement &amp;&amp; isContain) {\n            this._hover(nodeId);\n        } else if (!hasClass || (hasClass &amp;&amp; !isContain)) {\n            this._unhover();\n        }\n\n        if (this.isSortable) {\n            boundaryType = this._getBoundaryType(targetPos, mousePos);\n            this._drawBoundaryLine(targetPos, boundaryType);\n        }\n    },\n\n    /**\n     * Act to hover on tree item\n     * @param {string} nodeId - Tree node id\n     */\n    _hover: function(nodeId) {\n        var tree = this.tree;\n        var hoverEl = document.getElementById(nodeId);\n\n        this.hoveredElement = hoverEl;\n\n        util.addClass(hoverEl, this.hoverClassName);\n\n        if (!tree.isLeaf(nodeId)) {\n            this.timer = setTimeout(function() {\n                if (tree.getNodeIdFromElement(hoverEl) === nodeId) {\n                    tree.open(nodeId);\n                }\n            }, this.autoOpenDelay);\n        }\n    },\n\n    /**\n     * Act to unhover on tree item\n     */\n    _unhover: function() {\n        clearTimeout(this.timer);\n\n        util.removeClass(this.hoveredElement, this.hoverClassName);\n\n        this.hoveredElement = null;\n        this.timer = null;\n    },\n\n    /**\n     * Check contained state of current target\n     * @param {object} targetPos - Position of tree item\n     * @param {object} mousePos - Position of moved mouse\n     * @returns {boolean} Contained state\n     */\n    _isContain: function(targetPos, mousePos) {\n        var top = targetPos.top;\n        var bottom = targetPos.bottom;\n\n        if (this.isSortable) {\n            top += this.lineBoundary.top;\n            bottom -= this.lineBoundary.bottom;\n        }\n\n        if (targetPos.left &lt; mousePos.x &amp;&amp; targetPos.right > mousePos.x &amp;&amp;\n            top &lt; mousePos.y &amp;&amp; bottom > mousePos.y) {\n            return true;\n        }\n\n        return false;\n    },\n\n    /**\n     * Get boundary type by mouse position\n     * @param {object} targetPos - Position of tree item\n     * @param {object} mousePos - Position of moved mouse\n     * @returns {string} Position type in boundary\n     */\n    _getBoundaryType: function(targetPos, mousePos) {\n        var type;\n\n        if (mousePos.y &lt; targetPos.top + this.lineBoundary.top) {\n            type = 'top';\n        } else if (mousePos.y > targetPos.bottom - this.lineBoundary.bottom) {\n            type = 'bottom';\n        }\n\n        return type;\n    },\n\n    /**\n     * Draw boundary line on tree\n     * @param {object} targetPos - Position of tree item\n     * @param {string} boundaryType - Position type in boundary\n     */\n    _drawBoundaryLine: function(targetPos, boundaryType) {\n        var style = this.lineElement.style;\n        var lineHeight;\n        var scrollTop;\n\n        if (boundaryType) {\n            scrollTop = this.tree.rootElement.parentNode.scrollTop + util.getWindowScrollTop();\n            lineHeight = Math.round(this.lineElement.offsetHeight / 2);\n\n            style.top = Math.round(targetPos[boundaryType]) - lineHeight + scrollTop + 'px';\n            style.visibility = 'visible';\n            this.movingLineType = boundaryType;\n        } else {\n            style.visibility = 'hidden';\n            this.movingLineType = null;\n        }\n    },\n\n    /**\n     * Get index for inserting\n     * @param {string} nodeId - Current selected helper node id\n     * @returns {number} Index number\n     */\n    _getIndexForInserting: function(nodeId) {\n        var index = this.tree.getNodeIndex(nodeId);\n\n        if (this.movingLineType === 'bottom') {\n            index += 1;\n        }\n\n        return index;\n    }\n});\n\nmodule.exports = Draggable;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"