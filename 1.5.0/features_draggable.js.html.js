tui.util.defineNamespace("fedoc.content", {});
fedoc.content["features_draggable.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>'use strict';\nvar util = require('./../util');\n\nvar defaultOptions = {\n    useHelper: true,\n    helperPos: {\n        y: 2,\n        x: 5\n    },\n    autoOpenDelay: 1500,\n    isSortable: false,\n    hoverClassName: 'tui-tree-hover',\n    lineClassName: 'tui-tree-line',\n    lineBoundary: {\n        top: 2,\n        bottom: 2\n    }\n};\nvar rejectedTagNames = [\n    'INPUT',\n    'BUTTON',\n    'UL'\n];\nvar selectKey = util.testProp(\n    ['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']\n);\nvar inArray = tui.util.inArray;\nvar forEach = tui.util.forEach;\nvar API_LIST = [];\n\n/**\n * Set the tree draggable\n * @class Draggable\n * @constructor\n * @param {Tree} tree - Tree\n * @param {Object} options - Options\n *     @param {boolean} options.useHelper - Using helper flag\n *     @param {{x: number, y:number}} options.helperPos - Helper position\n *     @param {Array.&lt;string>} options.rejectedTagNames - No draggable tag names\n *     @param {Array.&lt;string>} options.rejectedClassNames - No draggable class names\n *     @param {number} options.autoOpenDelay - Delay time while dragging to be opened\n *     @param {boolean} options.isSortable - Flag of whether using sortable dragging\n *     @param {string} options.hoverClassName - Class name for hovered node\n *     @param {string} options.lineClassName - Class name for moving position line\n *     @param {{top: number, bottom: number}} options.lineBoundary - Boundary value for visible moving line\n */\nvar Draggable = tui.util.defineClass(/** @lends Draggable.prototype */{/*eslint-disable*/\n    static: {\n        /**\n         * @static\n         * @memberOf Draggable\n         * @returns {Array.&lt;string>} API list of Draggable\n         */\n        getAPIList: function() {\n            return API_LIST.slice();\n        }\n    },\n\n    init: function(tree, options) { /*eslint-enable*/\n        options = tui.util.extend({}, defaultOptions, options);\n\n        /**\n         * Tree data\n         * @type {Tree}\n         */\n        this.tree = tree;\n\n        /**\n         * Drag helper element\n         * @type {HTMLElement}\n         */\n        this.helperElement = null;\n\n        /**\n         * Selectable element's property\n         * @type {string}\n         */\n        this.userSelectPropertyKey = null;\n\n        /**\n         * Selectable element's property value\n         * @type {string}\n         */\n        this.userSelectPropertyValue = null;\n\n        /**\n         * Dragging element's node id\n         * @type {string}\n         */\n        this.currentNodeId = null;\n\n        /**\n         * Current mouse overed element\n         * @type {HTMLElement}\n         */\n        this.hoveredElement = null;\n\n        /**\n         * Moving line type (\"top\" or \"bottom\")\n         * @type {string}\n         */\n        this.movingLineType = null;\n\n        /**\n         * Invoking time for setTimeout()\n         * @type {number}\n         */\n        this.timer = null;\n\n        /**\n         * Tag list for rejecting to drag\n         * @param {Array.&lt;string>}\n         */\n        this.rejectedTagNames = rejectedTagNames.concat(options.rejectedTagNames);\n\n        /**\n         * Class name list for rejecting to drag\n         * @param {Array.&lt;string>}\n         */\n        this.rejectedClassNames = [].concat(options.rejectedClassNames);\n\n        /**\n         * Using helper flag\n         * @type {boolean}\n         */\n        this.useHelper = options.useHelper;\n\n        /**\n         * Helper position\n         * @type {Object}\n         */\n        this.helperPos = options.helperPos;\n\n        /**\n         * Delay time while dragging to be opened\n         * @type {number}\n         */\n        this.autoOpenDelay = options.autoOpenDelay;\n\n        /**\n         * Flag of whether using sortable dragging\n         * @type {boolean}\n         */\n        this.isSortable = options.isSortable;\n\n        /**\n         * Class name for mouse overed node\n         * @type {string}\n         */\n        this.hoverClassName = options.hoverClassName;\n\n        /**\n         * Class name for moving position line\n         * @type {string}\n         */\n        this.lineClassName = options.lineClassName;\n\n        /**\n         * Boundary value for visible moving line\n         * @type {Object}\n         */\n        this.lineBoundary = options.lineBoundary;\n\n        this._initHelper();\n\n        if (this.isSortable) {\n            this._initMovingLine();\n        }\n\n        this._attachMousedown();\n    },\n\n    /**\n     * Disable this module\n     */\n    destroy: function() {\n        this._restoreTextSelection();\n        this._detachMousedown();\n    },\n\n    /**\n     * Change helper element position\n     * @param {object} mousePos - Current mouse position\n     * @private\n     */\n    _changeHelperPosition: function(mousePos) {\n        var helperStyle = this.helperElement.style;\n        var pos = this.tree.rootElement.getBoundingClientRect();\n\n        helperStyle.top = (mousePos.y - pos.top + this.helperPos.y) + 'px';\n        helperStyle.left = (mousePos.x - pos.left + this.helperPos.x) + 'px';\n        helperStyle.display = '';\n    },\n\n    /**\n     * Init helper element\n     * @private\n     */\n    _initHelper: function() {\n        var helperElement = document.createElement('span');\n        var helperStyle = helperElement.style;\n\n        helperStyle.position = 'absolute';\n        helperStyle.display = 'none';\n\n        this.tree.rootElement.parentNode.appendChild(helperElement);\n\n        this.helperElement = helperElement;\n    },\n\n    /**\n     * Init moving line element\n     * @private\n     */\n    _initMovingLine: function() {\n        var lineElement = document.createElement('div');\n        var lineStyle = lineElement.style;\n\n        lineStyle.position = 'absolute';\n        lineStyle.visibility = 'hidden';\n\n        lineElement.className = this.lineClassName;\n\n        this.tree.rootElement.parentNode.appendChild(lineElement);\n\n        this.lineElement = lineElement;\n    },\n\n    /**\n     * Set helper contents\n     * @param {string} text - Helper contents\n     * @private\n     */\n    _setHelper: function(text) {\n        this.helperElement.innerHTML = text;\n    },\n\n    /**\n     * Attach mouse down event\n     * @private\n     */\n    _attachMousedown: function() {\n        this._preventTextSelection();\n        this.tree.on('mousedown', this._onMousedown, this);\n    },\n\n    /**\n     * Detach mousedown event\n     * @private\n     */\n    _detachMousedown: function() {\n        this.tree.off(this);\n    },\n\n    /**\n     * Prevent text-selection\n     * @private\n     */\n    _preventTextSelection: function() {\n        var style = this.tree.rootElement.style;\n\n        util.addEventListener(this.tree.rootElement, 'selectstart', util.preventDefault);\n\n        this.userSelectPropertyKey = selectKey;\n        this.userSelectPropertyValue = style[selectKey];\n\n        style[selectKey] = 'none';\n    },\n\n    /**\n     * Restore text-selection\n     * @private\n     */\n    _restoreTextSelection: function() {\n        util.removeEventListener(this.tree.rootElement, 'selectstart', util.preventDefault);\n\n        if (this.userSelectPropertyKey) {\n            this.tree.rootElement.style[this.userSelectPropertyKey] = this.userSelectPropertyValue;\n        }\n    },\n\n    /**\n     * Return whether the target element is in rejectedTagNames or in rejectedClassNames\n     * @param {HTMLElement} target - Target element\n     * @returns {boolean} Whether the target is not draggable or draggable\n     * @private\n     */\n    _isNotDraggable: function(target) {\n        var tagName = target.tagName.toUpperCase();\n        var classNames = util.getClass(target).split(/\\s+/);\n        var result;\n\n        if (inArray(tagName, this.rejectedTagNames) !== -1) {\n            return true;\n        }\n\n        forEach(classNames, function(className) {\n            result = inArray(className, this.rejectedClassNames) !== -1;\n\n            return !result;\n        }, this);\n\n        return result;\n    },\n\n    /**\n     * Event handler - mousedown\n     * @param {MouseEvent} event - Mouse event\n     * @private\n     */\n    _onMousedown: function(event) {\n        var tree = this.tree;\n        var target = util.getTarget(event);\n\n        if (util.isRightButton(event) || this._isNotDraggable(target)) {\n            return;\n        }\n\n        util.preventDefault(event);\n\n        this.currentNodeId = tree.getNodeIdFromElement(target);\n\n        if (this.useHelper) {\n            this._setHelper(target.innerText || target.textContent);\n        }\n\n        tree.on({\n            mousemove: this._onMousemove,\n            mouseup: this._onMouseup\n        }, this);\n    },\n\n    /**\n     * Event handler - mousemove\n     * @param {MouseEvent} event - Mouse event\n     * @private\n     */\n    _onMousemove: function(event) {\n        var mousePos = util.getMousePos(event);\n        var target = util.getTarget(event);\n        var nodeId;\n\n        if (!this.useHelper) {\n            return;\n        }\n\n        this._changeHelperPosition(mousePos);\n\n        nodeId = this.tree.getNodeIdFromElement(target);\n\n        if (nodeId) {\n            this._applyMoveAction(nodeId, mousePos);\n        }\n    },\n\n    /**\n     * Event handler - mouseup\n     * @param {MouseEvent} event - Mouse event\n     * @private\n     */\n    _onMouseup: function(event) {\n        var tree = this.tree;\n        var target = util.getTarget(event);\n        var nodeId = tree.getNodeIdFromElement(target);\n        var index = -1;\n\n        if (nodeId &amp;&amp; this.isSortable &amp;&amp; this.movingLineType) {\n            index = this._getIndexForInserting(nodeId);\n            nodeId = tree.getParentId(nodeId);\n        }\n\n        if (this.currentNodeId !== nodeId) {\n            tree.move(this.currentNodeId, nodeId, index);\n        }\n\n        this._reset();\n    },\n\n    /**\n     * Apply move action that are delay effect and sortable moving node\n     * @param {strig} nodeId - Selected tree node id\n     * @param {object} mousePos - Current mouse position\n     * @private\n     */\n    _applyMoveAction: function(nodeId, mousePos) {\n        var currentElement = document.getElementById(nodeId);\n        var targetPos = currentElement.getBoundingClientRect();\n        var hasClass = util.hasClass(currentElement, this.hoverClassName);\n        var isContain = this._isContain(targetPos, mousePos);\n        var boundaryType;\n\n        if (!this.hoveredElement &amp;&amp; isContain) {\n            this.hoveredElement = currentElement;\n            this._hover(nodeId);\n        } else if (!hasClass || (hasClass &amp;&amp; !isContain)) {\n            this._unhover();\n        }\n\n        if (this.isSortable) {\n            boundaryType = this._getBoundaryType(targetPos, mousePos);\n            this._drawBoundaryLine(targetPos, boundaryType);\n        }\n    },\n\n    /**\n     * Act to hover on tree item\n     * @param {string} nodeId - Tree node id\n     * @private\n     */\n    _hover: function(nodeId) {\n        var tree = this.tree;\n\n        util.addClass(this.hoveredElement, this.hoverClassName);\n\n        if (tree.isLeaf(nodeId)) {\n            return;\n        }\n\n        this.timer = setTimeout(function() {\n            tree.open(nodeId);\n        }, this.autoOpenDelay);\n    },\n\n    /**\n     * Act to unhover on tree item\n     * @private\n     */\n    _unhover: function() {\n        clearTimeout(this.timer);\n\n        util.removeClass(this.hoveredElement, this.hoverClassName);\n\n        this.hoveredElement = null;\n        this.timer = null;\n    },\n\n    /**\n     * Check contained state of current target\n     * @param {object} targetPos - Position of tree item\n     * @param {object} mousePos - Position of moved mouse\n     * @returns {boolean} Contained state\n     * @private\n     */\n    _isContain: function(targetPos, mousePos) {\n        var top = targetPos.top;\n        var bottom = targetPos.bottom;\n\n        if (this.isSortable) {\n            top += this.lineBoundary.top;\n            bottom -= this.lineBoundary.bottom;\n        }\n\n        if (targetPos.left &lt; mousePos.x &amp;&amp;\n            targetPos.right > mousePos.x &amp;&amp;\n            top &lt; mousePos.y &amp;&amp; bottom > mousePos.y) {\n            return true;\n        }\n\n        return false;\n    },\n\n    /**\n     * Get boundary type by mouse position\n     * @param {object} targetPos - Position of tree item\n     * @param {object} mousePos - Position of moved mouse\n     * @returns {string} Position type in boundary\n     * @private\n     */\n    _getBoundaryType: function(targetPos, mousePos) {\n        var type;\n\n        if (mousePos.y &lt; targetPos.top + this.lineBoundary.top) {\n            type = 'top';\n        } else if (mousePos.y > targetPos.bottom - this.lineBoundary.bottom) {\n            type = 'bottom';\n        }\n\n        return type;\n    },\n\n    /**\n     * Draw boundary line on tree\n     * @param {object} targetPos - Position of tree item\n     * @param {string} boundaryType - Position type in boundary\n     * @private\n     */\n    _drawBoundaryLine: function(targetPos, boundaryType) {\n        var style = this.lineElement.style;\n        var lineHeight;\n        var scrollTop;\n\n        if (boundaryType) {\n            scrollTop = this.tree.rootElement.parentNode.scrollTop + util.getWindowScrollTop();\n            lineHeight = Math.round(this.lineElement.offsetHeight / 2);\n\n            style.top = Math.round(targetPos[boundaryType]) - lineHeight + scrollTop + 'px';\n            style.visibility = 'visible';\n            this.movingLineType = boundaryType;\n        } else {\n            style.visibility = 'hidden';\n            this.movingLineType = null;\n        }\n    },\n\n    /**\n     * Get index for inserting\n     * @param {string} nodeId - Current selected helper node id\n     * @returns {number} Index number\n     * @private\n     */\n    _getIndexForInserting: function(nodeId) {\n        var index = this.tree.getNodeIndex(nodeId);\n\n        if (this.movingLineType === 'bottom') {\n            index += 1;\n        }\n\n        return index;\n    },\n\n    /**\n     * _reset properties and remove event\n     * @private\n     */\n    _reset: function() {\n        if (this.isSortable) {\n            this.lineElement.style.visibility = 'hidden';\n        }\n\n        if (this.hoveredElement) {\n            util.removeClass(this.hoveredElement, this.hoverClassName);\n            this.hoveredElement = null;\n        }\n\n        this.helperElement.style.display = 'none';\n\n        this.currentNodeId = null;\n        this.movingLineType = null;\n\n        this.tree.off(this, 'mousemove');\n        this.tree.off(this, 'mouseup');\n    }\n});\n\nmodule.exports = Draggable;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"