/*!
 * TOAST UI Tree
 * @version 3.5.6
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("tui-code-snippet"), require("tui-context-menu"));
	else if(typeof define === 'function' && define.amd)
		define(["tui-code-snippet", "tui-context-menu"], factory);
	else if(typeof exports === 'object')
		exports["Tree"] = factory(require("tui-code-snippet"), require("tui-context-menu"));
	else
		root["tui"] = root["tui"] || {}, root["tui"]["Tree"] = factory(root["tui"]["util"], root["tui"]["ContextMenu"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE_tui_code_snippet__, __WEBPACK_EXTERNAL_MODULE_tui_context_menu__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/css/tree.css":
/*!**************************!*\
  !*** ./src/css/tree.css ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack://tui.Tree/./src/css/tree.css?");

/***/ }),

/***/ "./src/js/consts/ajaxCommand.js":
/*!**************************************!*\
  !*** ./src/js/consts/ajaxCommand.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @fileoverview Set each command name using in Ajax feature\n * @author NHN. FE dev Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Ajax comman in tree\n * @type {Object.<string, string>}\n */\nmodule.exports = {\n  READ: 'read',\n  CREATE: 'create',\n  UPDATE: 'update',\n  DELETE: 'remove',\n  DELETE_ALL_CHILDREN: 'removeAllChildren',\n  MOVE: 'move'\n};\n\n\n//# sourceURL=webpack://tui.Tree/./src/js/consts/ajaxCommand.js?");

/***/ }),

/***/ "./src/js/consts/defaultOption.js":
/*!****************************************!*\
  !*** ./src/js/consts/defaultOption.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @fileoverview Set default value of options\n * @author NHN. FE dev Lab <dl_javascript@nhn.com>\n */\n\n/**\n * A default values for tree\n * @const\n * @type {Object}\n * @property {array} data - A data to be used on tree\n * @property {string} nodeDefaultState - Node state\n * @property {string} nodeIdPrefix - Node id prefix\n * @property {object} stateLabel - State label in node\n *  @property {string} stateLabel.opened - '-'\n *  @property {string} stateLabel.closed - '+'\n * @property {object} template - Template html for the nodes.\n *  @property {string} template.internalNode - Template html for internal node.\n *  @property {string} template.leafNode - Template html for leaf node.\n * @property {object} classNames - Class names of elements in tree\n *  @property {string} openedClass - Class name for opened node\n *  @property {string} closedClass - Class name for closed node\n *  @property {string} nodeClass - Class name for node\n *  @property {string} leafClass - Class name for leaf node\n *  @property {string} subtreeClass  - Class name for subtree in internal node\n *  @property {string} toggleBtnClass - Class name for toggle button in internal node\n *  @property {string} textClass - Class name for text element in a node\n */\nmodule.exports = {\n  data: [],\n  nodeDefaultState: 'closed',\n  stateLabels: {\n    opened: '-',\n    closed: '+'\n  },\n  nodeIdPrefix: 'tui-tree-node-',\n  classNames: {\n    nodeClass: 'tui-tree-node',\n    leafClass: 'tui-tree-leaf',\n    openedClass: 'tui-tree-opened',\n    closedClass: 'tui-tree-closed',\n    subtreeClass: 'tui-js-tree-subtree',\n    toggleBtnClass: 'tui-js-tree-toggle-btn',\n    textClass: 'tui-js-tree-text',\n    btnClass: 'tui-tree-content-wrapper'\n  },\n  template: {\n    internalNode:\n      '<div class=\"tui-tree-content-wrapper\">' +\n      '<button type=\"button\" class=\"tui-tree-toggle-btn {{toggleBtnClass}}\">' +\n      '<span class=\"tui-ico-tree\"></span>' +\n      '{{stateLabel}}' +\n      '</button>' +\n      '<span class=\"tui-tree-text {{textClass}}\">' +\n      '<span class=\"tui-tree-ico tui-ico-folder\"></span>' +\n      '{{text}}' +\n      '</span>' +\n      '</div>' +\n      '<ul class=\"tui-tree-subtree {{subtreeClass}}\">{{children}}</ul>',\n    leafNode:\n      '<div class=\"tui-tree-content-wrapper\">' +\n      '<span class=\"tui-tree-text {{textClass}}\">' +\n      '<span class=\"tui-tree-ico tui-ico-file\"></span>' +\n      '{{text}}' +\n      '</span>' +\n      '</div>'\n  },\n  indent: 23, // value of default css,\n  usageStatistics: true\n};\n\n\n//# sourceURL=webpack://tui.Tree/./src/js/consts/defaultOption.js?");

/***/ }),

/***/ "./src/js/consts/messages.js":
/*!***********************************!*\
  !*** ./src/js/consts/messages.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @fileoverview Set error messages\n * @author NHN. FE dev Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Messages for tree\n * @type {Object.<string, string>}\n */\nmodule.exports = {\n  INVALID_CONTAINER_ELEMENT: '\"tui-tree\": The container element is invalid.',\n  INVALID_API: '\"tui-tree\": INVALID_API',\n  INVALID_API_SELECTABLE: '\"tui-tree\": The feature-\"Selectable\" is not enabled.',\n  INVALID_API_EDITABLE: '\"tui-tree\": The feature-\"Editable\" is not enabled.',\n  INVALID_API_DRAGGABLE: '\"tui-tree\": The feature-\"Draggable\" is not enabled.',\n  INVALID_API_CHECKBOX: '\"tui-tree\": The feature-\"Checkbox\" is not enabled.'\n};\n\n\n//# sourceURL=webpack://tui.Tree/./src/js/consts/messages.js?");

/***/ }),

/***/ "./src/js/consts/outerTemplate.js":
/*!****************************************!*\
  !*** ./src/js/consts/outerTemplate.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* eslint-disable no-useless-concat */\n/**\n * @fileoverview Set outer template\n * @author NHN. FE dev Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Outer template\n * @type {{internalNode: string, leafNode: string}}\n */\nmodule.exports = {\n  ROOT: '<ul class=\"tui-tree tui-tree-root\"></ul>',\n  INTERNAL_NODE: '<li id=\"{{id}}\" class=\"{{nodeClass}} {{stateClass}}\">' + '{{innerTemplate}}' + '</li>',\n  LEAF_NODE: '<li id=\"{{id}}\" class=\"{{nodeClass}} {{leafClass}}\">' + '{{innerTemplate}}' + '</li>'\n};\n\n\n//# sourceURL=webpack://tui.Tree/./src/js/consts/outerTemplate.js?");

/***/ }),

/***/ "./src/js/consts/states.js":
/*!*********************************!*\
  !*** ./src/js/consts/states.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @fileoverview Set default value of toggle button\n * @author NHN. FE dev Lab <dl_javascript@nhn.com>\n */\n\n/**\n * States in tree\n * @type {Object.<string, string>}\n */\nmodule.exports = {\n  /**\n   * States of node\n   * @type {{OPENED: string, CLOSED: string}}\n   */\n  node: {\n    OPENED: 'opened',\n    CLOSED: 'closed'\n  }\n};\n\n\n//# sourceURL=webpack://tui.Tree/./src/js/consts/states.js?");

/***/ }),

/***/ "./src/js/features/ajax.js":
/*!*********************************!*\
  !*** ./src/js/features/ajax.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @fileoverview Feature that tree action is enable to communicate server\n * @author NHN. FE dev Lab <dl_javascript@nhn.com>\n */\nvar snippet = __webpack_require__(/*! tui-code-snippet */ \"tui-code-snippet\");\nvar API_LIST = [];\nvar LOADER_CLASSNAME = 'tui-tree-loader';\n\n/**\n * Set Ajax feature on tree\n * @class Ajax\n * @param {Tree} tree - Tree\n * @param {Object} options - Options\n *  @param {Object} options.command - Each Ajax request command options\n *  @param {Function} [options.parseData] - Function to parse and return the response data\n *  @param {string} [options.loaderClassName] - Classname of loader element\n *  @param {boolean} [options.isLoadRoot] - Whether load data from root node or not\n * @ignore\n */\nvar Ajax = snippet.defineClass(\n  /** @lends Ajax.prototype */ {\n    static: {\n      /**\n       * @static\n       * @memberof Ajax\n       * @returns {Array.<string>} API list of Ajax\n       */\n      getAPIList: function() {\n        return API_LIST.slice();\n      }\n    },\n    init: function(tree, options) {\n      options = snippet.extend({}, options);\n\n      /**\n       * Tree\n       * @type {Tree}\n       */\n      this.tree = tree;\n\n      /**\n       * Option for each request command\n       * @type {Object}\n       */\n      this.command = options.command;\n\n      /**\n       * Callback for parsing the response data\n       * @type {?Function}\n       */\n      this.parseData = options.parseData || null;\n\n      /**\n       * Classname of loader element\n       * @type {string}\n       */\n      this.loaderClassName = options.loaderClassName || LOADER_CLASSNAME;\n\n      /**\n       * State of loading root data or not\n       * @type {boolean}\n       */\n      this.isLoadRoot = !snippet.isUndefined(options.isLoadRoot) ? options.isLoadRoot : true;\n\n      /**\n       * Loader element\n       * @type {HTMLElement}\n       */\n      this.loader = null;\n\n      this._createLoader();\n\n      tree.on('initFeature', snippet.bind(this._onInitFeature, this));\n    },\n\n    /**\n     * Custom event handler \"initFeature\"\n     * @private\n     */\n    _onInitFeature: function() {\n      if (!this.isLoadRoot) {\n        return;\n      }\n\n      this.tree.resetAllData();\n    },\n\n    /**\n     * Disable this module\n     */\n    destroy: function() {\n      var tree = this.tree;\n\n      this._removeLoader();\n\n      tree.off(this);\n    },\n\n    /**\n     * Load data to request server\n     * @param {string} type - Command type\n     * @param {Function} callback - Executed function after response\n     * @param {Object} [params] - Values to make \"data\" property using request\n     */\n    loadData: function(type, callback, params) {\n      var self = this;\n      var options;\n\n      if (!this.command || !this.command[type] || !this.command[type].url) {\n        return;\n      }\n\n      options = this._getDefaultRequestOptions(type, params);\n\n      /**\n       * @event Tree#beforeAjaxRequest\n       * @type {object} evt - Event data\n       * @property {string} command - Command type\n       * @property {object} [data] - Request data\n       * @example\n       * tree.on('beforeAjaxRequest', function(evt) {\n       *     console.log('before ' + evt.command + ' request!');\n       *     return false; // It cancels request\n       *     // return true; // It fires request\n       * });\n       */\n      if (\n        !this.tree.invoke('beforeAjaxRequest', {\n          type: type,\n          params: params\n        })\n      ) {\n        return;\n      }\n\n      this._showLoader();\n\n      options.success = function(response) {\n        self._responseSuccess(type, callback, response);\n      };\n\n      options.error = function() {\n        self._responseError(type);\n      };\n\n      $.ajax(options);\n    },\n\n    /**\n     * Processing when response is success\n     * @param {string} type - Command type\n     * @param {Function} callback - Executed function after response\n     * @param {Object|boolean} [response] - Response data from server or return value of \"parseData\"\n     * @private\n     */\n    _responseSuccess: function(type, callback, response) {\n      var tree = this.tree;\n      var data;\n\n      this._hideLoader();\n\n      if (this.parseData) {\n        response = this.parseData(type, response);\n      }\n\n      if (response) {\n        data = callback(response);\n\n        /**\n         * @event Tree#successAjaxResponse\n         * @type {object} evt - Event data\n         * @property {string} command - Command type\n         * @property {object} [data] - Return value of executed command callback\n         * @example\n         * tree.on('successAjaxResponse', function(evt) {\n         *     console.log(evt.command + ' response is success!');\n         *     if (data) {\n         *           console.log('data:' + evt.data);\n         *     }\n         * });\n         */\n        tree.fire('successAjaxResponse', {\n          type: type,\n          data: data\n        });\n      } else {\n        /**\n         * @event Tree#failAjaxResponse\n         * @type {object} evt - Event data\n         * @property {string} command - Command type\n         * @example\n         * tree.on('failAjaxResponse', function(evt) {\n         *     console.log(evt.command + ' response is fail!');\n         * });\n         */\n        tree.fire('failAjaxResponse', {type: type});\n      }\n    },\n\n    /**\n     * Processing when response is error\n     * @param {string} type - Command type\n     * @private\n     */\n    _responseError: function(type) {\n      this._hideLoader();\n\n      /**\n       * @event Tree#errorAjaxResponse\n       * @type {object} evt - Event data\n       * @property {string} command - Command type\n       * @example\n       * tree.on('errorAjaxResponse', function(evt) {\n       *     console.log(evt.command + ' response is error!');\n       * });\n       */\n      this.tree.fire('errorAjaxResponse', {type: type});\n    },\n\n    /**\n     * Get default request options\n     * @param {string} type - Command type\n     * @param {Object} [params] - Value of request option \"data\"\n     * @returns {Object} Default options to request\n     * @private\n     */\n    _getDefaultRequestOptions: function(type, params) {\n      var options = this.command[type];\n\n      if (snippet.isFunction(options.url)) {\n        // for restful API url\n        options.url = options.url(params);\n      }\n\n      if (snippet.isFunction(options.data)) {\n        // for custom request data\n        options.data = options.data(params);\n      }\n\n      options.type = options.type ? options.type.toLowerCase() : 'get';\n      options.dataType = options.dataType || 'json';\n\n      return options;\n    },\n\n    /**\n     * Create loader element\n     * @private\n     */\n    _createLoader: function() {\n      var tree = this.tree;\n      var loader = document.createElement('span');\n\n      loader.className = this.loaderClassName;\n      loader.style.display = 'none';\n\n      tree.rootElement.parentNode.appendChild(loader);\n\n      this.loader = loader;\n    },\n\n    /**\n     * Remove loader element\n     * @private\n     */\n    _removeLoader: function() {\n      var tree = this.tree;\n      var loader = this.loader;\n\n      tree.rootElement.parentNode.removeChild(loader);\n\n      this.loader = null;\n    },\n\n    /**\n     * Show loader element on tree\n     * @private\n     */\n    _showLoader: function() {\n      this.loader.style.display = 'block';\n    },\n\n    /**\n     * Hide loader element on tree\n     * @private\n     */\n    _hideLoader: function() {\n      this.loader.style.display = 'none';\n    }\n  }\n);\n\nmodule.exports = Ajax;\n\n\n//# sourceURL=webpack://tui.Tree/./src/js/features/ajax.js?");

/***/ }),

/***/ "./src/js/features/checkbox.js":
/*!*************************************!*\
  !*** ./src/js/features/checkbox.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @fileoverview Feature that each tree node is possible to check and uncheck\n * @author NHN. FE dev Lab <dl_javascript@nhn.com>\n */\nvar util = __webpack_require__(/*! ../util.js */ \"./src/js/util.js\");\nvar snippet = __webpack_require__(/*! tui-code-snippet */ \"tui-code-snippet\");\n\nvar API_LIST = [\n  'check',\n  'uncheck',\n  'toggleCheck',\n  'isChecked',\n  'isIndeterminate',\n  'isUnchecked',\n  'getCheckedList',\n  'getTopCheckedList',\n  'getBottomCheckedList'\n];\n\n/* Checkbox tri-states */\nvar STATE_CHECKED = 1,\n  STATE_UNCHECKED = 2,\n  STATE_INDETERMINATE = 3,\n  DATA_KEY_FOR_CHECKBOX_STATE = '__CheckBoxState__',\n  DATA = {},\n  CHECKED_CLASSNAME = 'tui-is-checked',\n  INDETERMINATE_CLASSNAME = 'tui-checkbox-root';\n\n/* Checkbox cascade-states */\nvar CASCADE_UP = 'up',\n  CASCADE_DOWN = 'down',\n  CASCADE_BOTH = 'both',\n  CASCADE_NONE = false;\n\nvar filter = snippet.filter,\n  forEach = snippet.forEach,\n  inArray = snippet.inArray;\n/**\n * Set the checkbox-api\n * @class Checkbox\n * @param {Tree} tree - Tree\n * @param {Object} option - Option\n *  @param {string} option.checkboxClassName - Classname of checkbox element\n *  @param {string|boolean} [option.checkboxCascade='both'] - 'up', 'down', 'both', false\n * @ignore\n */\nvar Checkbox = snippet.defineClass(\n  /** @lends Checkbox.prototype */ {\n    static: {\n      /**\n       * @static\n       * @memberof Checkbox\n       * @returns {Array.<string>} API list of checkbox\n       */\n      getAPIList: function() {\n        return API_LIST.slice();\n      }\n    },\n    init: function(tree, option) {\n      option = snippet.extend({}, option);\n\n      this.tree = tree;\n      this.checkboxClassName = option.checkboxClassName;\n      this.checkboxCascade = this._initCascadeOption(option.checkboxCascade);\n      this.checkedList = [];\n      this.rootCheckbox = document.createElement('INPUT');\n      this.rootCheckbox.type = 'checkbox';\n\n      this._setAPIs();\n      this._attachEvents();\n    },\n\n    /**\n     * Disable this module\n     */\n    destroy: function() {\n      var tree = this.tree;\n\n      tree.off(this);\n      forEach(API_LIST, function(apiName) {\n        delete tree[apiName];\n      });\n    },\n\n    /**\n     * @param {string|boolean} cascadeOption - Cascade option\n     * @returns {string|boolean} Cascade option\n     * @private\n     */\n    _initCascadeOption: function(cascadeOption) {\n      var cascadeOptions = [CASCADE_UP, CASCADE_DOWN, CASCADE_BOTH, CASCADE_NONE];\n      if (inArray(cascadeOption, cascadeOptions) === -1) {\n        cascadeOption = CASCADE_BOTH;\n      }\n\n      return cascadeOption;\n    },\n\n    /**\n     * Set apis of checkbox tree\n     * @private\n     */\n    _setAPIs: function() {\n      var tree = this.tree,\n        bind = snippet.bind;\n\n      forEach(\n        API_LIST,\n        function(apiName) {\n          tree[apiName] = bind(this[apiName], this);\n        },\n        this\n      );\n    },\n\n    /**\n     * Attach event to tree instance\n     * @private\n     */\n    _attachEvents: function() {\n      this.tree.on(\n        {\n          singleClick: function(event) {\n            var target = util.getTarget(event);\n\n            if (util.getElementsByClassName(target, this.checkboxClassName)) {\n              this._changeCustomCheckbox(target);\n            }\n          },\n          afterDraw: function(ev) {\n            if (this.tree.isMovingNode) {\n              return;\n            }\n            this._reflectChanges(ev.nodeId);\n          },\n          move: function(data) {\n            // @TODO - Optimization\n            this._reflectChanges(data.originalParentId);\n            this._reflectChanges(data.newParentId);\n          }\n        },\n        this\n      );\n    },\n\n    /**\n     * Change custom checkbox\n     * @param {HTMLElement} target - Label element\n     */\n    _changeCustomCheckbox: function(target) {\n      var self = this;\n      var nodeId = this.tree.getNodeIdFromElement(target);\n      var inputElement = target.getElementsByTagName('input')[0];\n      var eventType = util.getChangeEventName();\n      var state;\n\n      /**\n       * Change event handler\n       */\n      function onChange() {\n        state = self._getStateFromCheckbox(inputElement);\n        util.removeEventListener(inputElement, eventType, onChange);\n        self._continuePostprocessing(nodeId, state);\n      }\n\n      util.addEventListener(inputElement, eventType, onChange);\n    },\n\n    /**\n     * Reflect the changes on node.\n     * @param {string} nodeId - Node id\n     * @private\n     */\n    _reflectChanges: function(nodeId) {\n      this.tree.each(\n        function(descendant, descendantId) {\n          this._setState(descendantId, this._getState(descendantId), true);\n        },\n        nodeId,\n        this\n      );\n      this._judgeOwnState(nodeId);\n      this._updateAllAncestorsState(nodeId);\n    },\n\n    /**\n     * Set checkbox attributes (checked, indeterminate)\n     * @param {Element} checkbox - Checkbox element\n     * @param {boolean} isChecked - \"checked\"\n     * @param {boolean} isIndeterminate - \"indeterminate\"\n     * @private\n     */\n    _setCheckboxAttr: function(checkbox, isChecked, isIndeterminate) {\n      checkbox.indeterminate = isIndeterminate;\n      checkbox.checked = isChecked;\n    },\n\n    /**\n     * Get checking state of node\n     * @param {string} nodeId - Node id\n     * @param {number} state - State for checkbox\n     * @param {boolean} [stopPropagation] - If true, stop changing state propagation\n     * @private\n     */\n    _setState: function(nodeId, state, stopPropagation) {\n      var checkbox = this._getCheckboxElement(nodeId);\n\n      if (!checkbox) {\n        return;\n      }\n\n      switch (state) {\n        case STATE_CHECKED:\n          this._setCheckboxAttr(checkbox, true, false);\n          break;\n        case STATE_UNCHECKED:\n          this._setCheckboxAttr(checkbox, false, false);\n          break;\n        case STATE_INDETERMINATE:\n          this._setCheckboxAttr(checkbox, false, true);\n          break;\n        default:\n          // no more process if the state is invalid\n          return;\n      }\n\n      this._continuePostprocessing(nodeId, state, stopPropagation);\n    },\n\n    /**\n     * Get checking state of node\n     * @param {string} nodeId - Node id\n     * @returns {number} Checking state\n     * @private\n     */\n    _getState: function(nodeId) {\n      var tree = this.tree,\n        state = tree.getNodeData(nodeId)[DATA_KEY_FOR_CHECKBOX_STATE],\n        checkbox;\n\n      if (!state) {\n        checkbox = this._getCheckboxElement(nodeId);\n        state = this._getStateFromCheckbox(checkbox);\n      }\n\n      return state;\n    },\n\n    /**\n     * Get checking state of node element\n     * @private\n     * @param {Element} checkbox - Checkbox element\n     * @returns {?number} Checking state\n     */\n    _getStateFromCheckbox: function(checkbox) {\n      var state;\n\n      if (!checkbox) {\n        return null;\n      }\n\n      if (checkbox.checked) {\n        state = STATE_CHECKED;\n      } else if (checkbox.indeterminate) {\n        state = STATE_INDETERMINATE;\n      } else {\n        state = STATE_UNCHECKED;\n      }\n\n      return state;\n    },\n\n    /**\n     * Continue post-processing from changing:checkbox-state\n     * @param {string} nodeId - Node id\n     * @param {number} state - Checkbox state\n     * @param {boolean} [stopPropagation] - If true, stop update-propagation\n     * @private\n     */\n    _continuePostprocessing: function(nodeId, state, stopPropagation) {\n      var tree = this.tree,\n        checkedList = this.checkedList,\n        eventName;\n\n      /* Prevent duplicated node id */\n      util.removeItemFromArray(nodeId, checkedList);\n\n      if (state === STATE_CHECKED) {\n        checkedList.push(nodeId);\n        /**\n         * @event Tree#check\n         * @type {object} evt - Event data\n         * @property {string} nodeId - Checked node id\n         * @example\n         * tree.on('check', function(evt) {\n         *     console.log('checked: ' + evt.nodeId);\n         * });\n         */\n        eventName = 'check';\n      } else if (state === STATE_UNCHECKED) {\n        /**\n         * @event Tree#uncheck\n         * @type {object} evt - Event data\n         * @property {string} nodeId - Unchecked node id\n         * @example\n         * tree.on('uncheck', function(evt) {\n         *     console.log('unchecked: ' + evt.nodeId);\n         * });\n         */\n        eventName = 'uncheck';\n      }\n      DATA[DATA_KEY_FOR_CHECKBOX_STATE] = state;\n\n      tree.setNodeData(nodeId, DATA, {\n        isSilent: true\n      });\n\n      this._setClassName(nodeId, state);\n\n      if (!stopPropagation) {\n        this._propagateState(nodeId, state);\n        tree.fire(eventName, {nodeId: nodeId});\n      }\n    },\n\n    /**\n     * Set class name on label element\n     * @param {string} nodeId - Node id for finding input element\n     * @param {number} state - Checked state number\n     */\n    _setClassName: function(nodeId, state) {\n      var parentElement = this._getCheckboxElement(nodeId).parentNode;\n      var labelElement;\n\n      if (parentElement && parentElement.parentNode) {\n        labelElement = parentElement.parentNode;\n\n        util.removeClass(labelElement, INDETERMINATE_CLASSNAME);\n        util.removeClass(labelElement, CHECKED_CLASSNAME);\n\n        if (state === 1) {\n          util.addClass(labelElement, CHECKED_CLASSNAME);\n        } else if (state === 3) {\n          util.addClass(labelElement, INDETERMINATE_CLASSNAME);\n          util.addClass(labelElement, CHECKED_CLASSNAME);\n        }\n      }\n    },\n\n    /**\n     * Propagate a node state to descendants and ancestors for updating their states\n     * @param {string} nodeId - Node id\n     * @param {number} state - Checkbox state\n     * @private\n     */\n    _propagateState: function(nodeId, state) {\n      if (state === STATE_INDETERMINATE) {\n        return;\n      }\n      if (inArray(this.checkboxCascade, [CASCADE_DOWN, CASCADE_BOTH]) > -1) {\n        this._updateAllDescendantsState(nodeId, state);\n      }\n      if (inArray(this.checkboxCascade, [CASCADE_UP, CASCADE_BOTH]) > -1) {\n        this._updateAllAncestorsState(nodeId);\n      }\n    },\n\n    /**\n     * Update all descendants state\n     * @param {string} nodeId - Node id\n     * @param {number} state - State for checkbox\n     * @private\n     */\n    _updateAllDescendantsState: function(nodeId, state) {\n      this.tree.each(\n        function(descendant, descendantId) {\n          this._setState(descendantId, state, true);\n        },\n        nodeId,\n        this\n      );\n    },\n\n    /**\n     * Update all ancestors state\n     * @param {string} nodeId - Node id\n     * @private\n     */\n    _updateAllAncestorsState: function(nodeId) {\n      var tree = this.tree,\n        parentId = tree.getParentId(nodeId);\n\n      while (parentId) {\n        this._judgeOwnState(parentId);\n        parentId = tree.getParentId(parentId);\n      }\n    },\n\n    /**\n     * Judge own state from child node is changed\n     * @param {string} nodeId - Node id\n     * @private\n     */\n    _judgeOwnState: function(nodeId) {\n      var tree = this.tree,\n        childIds = tree.getChildIds(nodeId),\n        checked = true,\n        unchecked = true;\n\n      if (!childIds.length) {\n        checked = this.isChecked(nodeId);\n      } else {\n        forEach(\n          childIds,\n          function(childId) {\n            var state = this._getState(childId);\n            checked = checked && state === STATE_CHECKED;\n            unchecked = unchecked && state === STATE_UNCHECKED;\n\n            return checked || unchecked;\n          },\n          this\n        );\n      }\n\n      if (checked) {\n        this._setState(nodeId, STATE_CHECKED, true);\n      } else if (unchecked) {\n        this._setState(nodeId, STATE_UNCHECKED, true);\n      } else {\n        this._setState(nodeId, STATE_INDETERMINATE, true);\n      }\n    },\n\n    /**\n     * Get checkbox element of node\n     * @param {string} nodeId - Node id\n     * @returns {?HTMLElement} Checkbox element\n     * @private\n     */\n    _getCheckboxElement: function(nodeId) {\n      var tree = this.tree,\n        el,\n        nodeEl;\n\n      if (nodeId === tree.getRootNodeId()) {\n        el = this.rootCheckbox;\n      } else {\n        nodeEl = document.getElementById(nodeId);\n        if (!nodeEl) {\n          return null;\n        }\n        el = util.getElementsByClassName(nodeEl, this.checkboxClassName)[0];\n      }\n\n      return el;\n    },\n\n    /**\n     * Check node\n     * @memberof Tree.prototype\n     * @param {string} nodeId - Node id\n     * @example\n     * var nodeId = 'tui-tree-node-3';\n     * tree.check(nodeId);\n     */\n    check: function(nodeId) {\n      if (!this.isChecked(nodeId)) {\n        this._setState(nodeId, STATE_CHECKED);\n      }\n    },\n\n    /**\n     * Uncheck node\n     * @memberof Tree.prototype\n     * @param {string} nodeId - Node id\n     * @example\n     * var nodeId = 'tui-tree-node-3';\n     * tree.uncheck(nodeId);\n     */\n    uncheck: function(nodeId) {\n      if (!this.isUnchecked(nodeId)) {\n        this._setState(nodeId, STATE_UNCHECKED);\n      }\n    },\n\n    /**\n     * Toggle node checking\n     * @memberof Tree.prototype\n     * @param {string} nodeId - Node id\n     * @example\n     * var nodeId = 'tui-tree-node-3';\n     * tree.toggleCheck(nodeId);\n     */\n    toggleCheck: function(nodeId) {\n      if (!this.isChecked(nodeId)) {\n        this.check(nodeId);\n      } else {\n        this.uncheck(nodeId);\n      }\n    },\n\n    /**\n     * Whether the node is checked\n     * @memberof Tree.prototype\n     * @param {string} nodeId - Node id\n     * @returns {boolean} True if node is indeterminate\n     * @example\n     * var nodeId = 'tui-tree-node-3';\n     * tree.check(nodeId);\n     * console.log(tree.isChecked(nodeId)); // true\n     */\n    isChecked: function(nodeId) {\n      return STATE_CHECKED === this._getState(nodeId);\n    },\n\n    /**\n     * Whether the node is indeterminate\n     * @memberof Tree.prototype\n     * @param {string} nodeId - Node id\n     * @returns {boolean} True if node is indeterminate\n     * @example\n     * var nodeId = 'tui-tree-node-3';\n     * tree.check(nodeId);\n     * console.log(tree.isIndeterminate(nodeId)); // false\n     */\n    isIndeterminate: function(nodeId) {\n      return STATE_INDETERMINATE === this._getState(nodeId);\n    },\n\n    /**\n     * Whether the node is unchecked or not\n     * @memberof Tree.prototype\n     * @param {string} nodeId - Node id\n     * @returns {boolean} True if node is unchecked.\n     * @example\n     * var nodeId = 'tui-tree-node-3';\n     * tree.uncheck(nodeId);\n     * console.log(tree.isUnchecked(nodeId)); // true\n     */\n    isUnchecked: function(nodeId) {\n      return STATE_UNCHECKED === this._getState(nodeId);\n    },\n\n    /**\n     * Get checked list\n     * @memberof Tree.prototype\n     * @param {string} [parentId] - Node id (default: rootNode id)\n     * @returns {Array.<string>} Checked node ids\n     * @example\n     * //\n     * // node1(v)\n     * //   node2(v)\n     * //   node3(v)\n     * // node4\n     * //   node5(v)\n     * // node6\n     * //   node7(v)\n     * //     node8(v)\n     * //   node9\n     *\n     * var allCheckedList = tree.getCheckedList(); // ['node1', 'node2', 'node3' ,....]\n     * var descendantsCheckedList = tree.getCheekedList('node6'); // ['node7', 'node8']\n     */\n    getCheckedList: function(parentId) {\n      var tree = this.tree,\n        checkedList = this.checkedList;\n\n      if (!parentId) {\n        return checkedList.slice();\n      }\n\n      return filter(checkedList, function(nodeId) {\n        return tree.contains(parentId, nodeId);\n      });\n    },\n\n    /**\n     * Get top checked list\n     * @memberof Tree.prototype\n     * @param {string} [parentId] - Node id (default: rootNode id)\n     * @returns {Array.<string>} Checked node ids\n     * @example\n     * //\n     * // node1(v)\n     * //   node2(v)\n     * //   node3(v)\n     * // node4\n     * //   node5(v)\n     * // node6\n     * //   node7(v)\n     * //     node8(v)\n     * //   node9\n     *\n     * var allTopCheckedList = tree.getTopCheckedList(); // ['node1', 'node5', 'node7']\n     * var descendantsTopCheckedList = tree.getTopCheekedList('node6'); // ['node7']\n     */\n    getTopCheckedList: function(parentId) {\n      var tree = this.tree,\n        checkedList = [],\n        state;\n\n      parentId = parentId || tree.getRootNodeId();\n      state = this._getState(parentId);\n      if (state === STATE_CHECKED) {\n        checkedList = tree.getChildIds(parentId);\n      } else if (state === STATE_INDETERMINATE) {\n        checkedList = this.getCheckedList(parentId);\n        checkedList = filter(\n          checkedList,\n          function(nodeId) {\n            return !this.isChecked(tree.getParentId(nodeId));\n          },\n          this\n        );\n      }\n\n      return checkedList;\n    },\n\n    /**\n     * Get bottom checked list\n     * @memberof Tree.prototype\n     * @param {string} [parentId] - Node id (default: rootNode id)\n     * @returns {Array.<string>} Checked node ids\n     * @example\n     * //\n     * // node1(v)\n     * //   node2(v)\n     * //   node3(v)\n     * // node4\n     * //   node5(v)\n     * // node6\n     * //   node7(v)\n     * //     node8(v)\n     * //   node9\n     *\n     * var allBottomCheckedList = tree.getBottomCheckedList(); // ['node2', 'node3', 'node5', 'node8']\n     * var descendantsBottomCheckedList = tree.getBottomCheekedList('node6'); // ['node8']\n     */\n    getBottomCheckedList: function(parentId) {\n      var tree = this.tree,\n        checkedList;\n\n      parentId = parentId || tree.getRootNodeId();\n      checkedList = this.getCheckedList(parentId);\n\n      return filter(checkedList, function(nodeId) {\n        return tree.isLeaf(nodeId);\n      });\n    }\n  }\n);\n\nsnippet.CustomEvents.mixin(Checkbox);\nmodule.exports = Checkbox;\n\n\n//# sourceURL=webpack://tui.Tree/./src/js/features/checkbox.js?");

/***/ }),

/***/ "./src/js/features/contextMenu.js":
/*!****************************************!*\
  !*** ./src/js/features/contextMenu.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @fileoverview Feature that each tree node is possible to have context-menu\n * @author NHN. FE dev Lab <dl_javascript@nhn.com>\n */\nvar util = __webpack_require__(/*! ./../util */ \"./src/js/util.js\");\nvar snippet = __webpack_require__(/*! tui-code-snippet */ \"tui-code-snippet\");\nvar TuiContextMenu = __webpack_require__(/*! tui-context-menu */ \"tui-context-menu\");\nvar API_LIST = ['changeContextMenu'];\nvar styleKeys = ['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect'];\nvar enableProp = util.testProp(styleKeys);\nvar bind = snippet.bind;\n\n/**\n * Set ContextMenu feature on tree\n * @class ContextMenu\n * @param {Tree} tree - Tree\n * @param {Object} options - Options\n *     @param {Array.<Object>} options.menuData - Context menu data\n *     @param {boolean} options.usageStatistics - Whether to send the hostname to GA\n * @ignore\n */\nvar ContextMenu = snippet.defineClass(\n  /** @lends ContextMenu.prototype */ {\n    static: {\n      /**\n       * @static\n       * @memberof ContextMenu\n       * @returns {Array.<string>} API list of ContextMenu\n       */\n      getAPIList: function() {\n        return API_LIST.slice();\n      }\n    },\n    init: function(tree, options) {\n      var containerId = tree.rootElement.parentNode.id;\n\n      options = options || {};\n\n      /**\n       * Tree data\n       * @type {Tree}\n       */\n      this.tree = tree;\n\n      /**\n       * Tree selector for context menu\n       */\n      this.treeSelector = '#' + containerId;\n\n      /**\n       * Id of floating layer in tree\n       * @type {string}\n       */\n      this.flId = containerId + '-fl';\n\n      /**\n       * Info of context menu in tree\n       * @type {Object}\n       */\n      this.menu = this._generateContextMenu(options.usageStatistics);\n\n      /**\n       * Floating layer element\n       * @type {HTMLElement}\n       */\n      this.flElement = document.getElementById(this.flId);\n\n      /**\n       * Id of selected tree item\n       * @type {string}\n       */\n      this.selectedNodeId = null;\n\n      this.menu.register(this.treeSelector, bind(this._onSelect, this), options.menuData);\n\n      this.tree.on('contextmenu', this._onContextMenu, this);\n\n      this._preventTextSelection();\n\n      this._setAPIs();\n    },\n\n    /**\n     * Change current context-menu view\n     * @memberof Tree.prototype\n     * @requires ContextMenu\n     * @param {Array.<Object>} newMenuData - New context menu data\n     * @example\n     * tree.changeContextMenu([\n     *      {title: 'menu1'},\n     *      {title: 'menu2', disable: true},\n     *      {title: 'menu3', menu: [\n     *          {title: 'submenu1', disable: true},\n     *          {title: 'submenu2'}\n     *      ]}\n     * ]);\n     */\n    changeContextMenu: function(newMenuData) {\n      this.menu.unregister(this.treeSelector);\n      this.menu.register(this.treeSelector, bind(this._onSelect, this), newMenuData);\n    },\n\n    /**\n     * Disable ContextMenu feature\n     */\n    destroy: function() {\n      var tree = this.tree;\n\n      this.menu.destroy();\n\n      this._restoreTextSelection();\n      this._removeFloatingLayer();\n\n      tree.off(this);\n\n      snippet.forEach(API_LIST, function(apiName) {\n        delete tree[apiName];\n      });\n    },\n\n    /**\n     * Create floating layer for context menu\n     * @private\n     */\n    _createFloatingLayer: function() {\n      this.flElement = document.createElement('div');\n      this.flElement.id = this.flId;\n\n      document.body.appendChild(this.flElement);\n    },\n\n    /**\n     * Remove floating layer for context menu\n     * @private\n     */\n    _removeFloatingLayer: function() {\n      document.body.removeChild(this.flElement);\n      this.flElement = null;\n    },\n\n    /**\n     * Generate context menu in tree\n     * @returns {TuiContextMenu} Instance of TuiContextMenu\n     * @param {boolean} usageStatistics - Let us know the hostname.\n     * @private\n     */\n    _generateContextMenu: function(usageStatistics) {\n      if (!this.flElement) {\n        this._createFloatingLayer();\n      }\n\n      return new TuiContextMenu(this.flElement, {\n        usageStatistics: usageStatistics\n      });\n    },\n\n    /**\n     * Prevent text selection on selected tree item\n     * @private\n     */\n    _preventTextSelection: function() {\n      if (enableProp) {\n        this.tree.rootElement.style[enableProp] = 'none';\n      }\n    },\n\n    /**\n     * Restore text selection on selected tree item\n     * @private\n     */\n    _restoreTextSelection: function() {\n      if (enableProp) {\n        this.tree.rootElement.style[enableProp] = '';\n      }\n    },\n\n    /**\n     * Event handler on tree item\n     * @param {MouseEvent} e - Mouse event\n     * @private\n     */\n    _onContextMenu: function(e) {\n      var target = util.getTarget(e);\n\n      this.selectedNodeId = this.tree.getNodeIdFromElement(target);\n\n      /**\n       * @event Tree#beforeOpenContextMenu\n       * @type {object} evt - Event data\n       * @property {string} nodeId - Current selected node id\n       * @example\n       * tree.on('beforeOpenContextMenu', function(evt) {\n       *     console.log('nodeId: ' + evt.nodeId);\n       * });\n       */\n      this.tree.fire('beforeOpenContextMenu', {\n        nodeId: this.selectedNodeId\n      });\n    },\n\n    /**\n     * Event handler on context menu\n     * @param {MouseEvent} e - Mouse event\n     * @param {string} cmd - Options value of selected context menu (\"title\"|\"command\")\n     * @private\n     */\n    _onSelect: function(e, cmd) {\n      /**\n       * @event Tree#selectContextMenu\n       * @type {object} evt - Event data\n       * @property {string} cmd - Command type\n       * @property {string} nodeId - Node id\n       * @example\n       * tree.on('selectContextMenu', function(evt) {\n       *     var cmd = treeEvent.cmd; // key of context menu's data\n       *     var nodeId = treeEvent.nodeId;\n       *\n       *     console.log(evt.cmd, evt.nodeId);\n       * });\n       */\n      this.tree.fire('selectContextMenu', {\n        cmd: cmd,\n        nodeId: this.selectedNodeId\n      });\n    },\n\n    /**\n     * Set API of ContextMenu feature\n     * @private\n     */\n    _setAPIs: function() {\n      var tree = this.tree;\n\n      snippet.forEach(\n        API_LIST,\n        function(apiName) {\n          tree[apiName] = bind(this[apiName], this);\n        },\n        this\n      );\n    }\n  }\n);\n\nmodule.exports = ContextMenu;\n\n\n//# sourceURL=webpack://tui.Tree/./src/js/features/contextMenu.js?");

/***/ }),

/***/ "./src/js/features/draggable.js":
/*!**************************************!*\
  !*** ./src/js/features/draggable.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @fileoverview Feature that each tree node is possible to drag and drop\n * @author NHN. FE dev Lab <dl_javascript@nhn.com>\n */\nvar util = __webpack_require__(/*! ./../util */ \"./src/js/util.js\");\nvar snippet = __webpack_require__(/*! tui-code-snippet */ \"tui-code-snippet\");\n\nvar defaultOptions = {\n  useHelper: true,\n  helperPos: {\n    y: 2,\n    x: 5\n  },\n  helperClassName: 'tui-tree-drop',\n  dragItemClassName: 'tui-tree-drag',\n  hoverClassName: 'tui-tree-hover',\n  lineClassName: 'tui-tree-line',\n  lineBoundary: {\n    top: 4,\n    bottom: 4\n  },\n  autoOpenDelay: 1500,\n  isSortable: false\n};\nvar rejectedTagNames = ['INPUT', 'BUTTON', 'UL'];\nvar selectKey = util.testProp([\n  'userSelect',\n  'WebkitUserSelect',\n  'OUserSelect',\n  'MozUserSelect',\n  'msUserSelect'\n]);\nvar inArray = snippet.inArray;\nvar forEach = snippet.forEach;\nvar API_LIST = [];\n\n/**\n * Set the tree draggable\n * @class Draggable\n * @param {Tree} tree - Tree\n * @param {Object} options - Options\n *     @param {boolean} options.useHelper - Using helper flag\n *     @param {{x: number, y:number}} options.helperPos - Helper position (each minimum value is 4)\n *     @param {Array.<string>} options.rejectedTagNames - No draggable tag names\n *     @param {Array.<string>} options.rejectedClassNames - No draggable class names\n *     @param {number} options.autoOpenDelay - Delay time while dragging to be opened\n *     @param {boolean} options.isSortable - Flag of whether using sortable dragging\n *     @param {string} options.hoverClassName - Class name for hovered node\n *     @param {string} options.lineClassName - Class name for moving position line\n *     @param {string} options.helperClassName - Class name for helper's outer element\n *     @param {string} options.helperTemplate - Template string for helper's inner contents\n *     @param {{top: number, bottom: number}} options.lineBoundary - Boundary value for visible moving line\n * @ignore\n */\nvar Draggable = snippet.defineClass(\n  /** @lends Draggable.prototype */ {\n    static: {\n      /**\n       * @static\n       * @memberof Draggable\n       * @returns {Array.<string>} API list of Draggable\n       */\n      getAPIList: function() {\n        return API_LIST.slice();\n      }\n    },\n\n    init: function(tree, options) {\n      options = snippet.extend({}, defaultOptions, options);\n\n      /**\n       * Tree data\n       * @type {Tree}\n       */\n      this.tree = tree;\n\n      /**\n       * Drag helper element\n       * @type {HTMLElement}\n       */\n      this.helperElement = null;\n\n      /**\n       * Selectable element's property\n       * @type {string}\n       */\n      this.userSelectPropertyKey = null;\n\n      /**\n       * Selectable element's property value\n       * @type {string}\n       */\n      this.userSelectPropertyValue = null;\n\n      /**\n       * Dragging element's node id\n       * @type {string}\n       */\n      this.currentNodeId = null;\n\n      /**\n       * Current mouse overed element\n       * @type {HTMLElement}\n       */\n      this.hoveredElement = null;\n\n      /**\n       * Moving line type (\"top\" or \"bottom\")\n       * @type {string}\n       */\n      this.movingLineType = null;\n\n      /**\n       * Invoking time for setTimeout()\n       * @type {number}\n       */\n      this.timer = null;\n\n      /**\n       * Tag list for rejecting to drag\n       * @param {Array.<string>}\n       */\n      this.rejectedTagNames = rejectedTagNames.concat(options.rejectedTagNames);\n\n      /**\n       * Class name list for rejecting to drag\n       * @param {Array.<string>}\n       */\n      this.rejectedClassNames = [].concat(options.rejectedClassNames);\n\n      /**\n       * Using helper flag\n       * @type {boolean}\n       */\n      this.useHelper = options.useHelper;\n\n      /**\n       * Helper position\n       * @type {Object}\n       */\n      this.helperPos = options.helperPos;\n\n      /**\n       * Delay time while dragging to be opened\n       * @type {number}\n       */\n      this.autoOpenDelay = options.autoOpenDelay;\n\n      /**\n       * Flag of whether using sortable dragging\n       * @type {boolean}\n       */\n      this.isSortable = options.isSortable;\n\n      /**\n       * Class name for mouse overed node\n       * @type {string}\n       */\n      this.hoverClassName = options.hoverClassName;\n\n      /**\n       * Class name for moving position line\n       * @type {string}\n       */\n      this.lineClassName = options.lineClassName;\n\n      /**\n       * Boundary value for visible moving line\n       * @type {Object}\n       */\n      this.lineBoundary = options.lineBoundary;\n\n      /**\n       * Helper's outer element class name\n       * @type {string}\n       */\n      this.helperClassName = options.helperClassName;\n\n      this._initHelper();\n\n      if (this.isSortable) {\n        this._initMovingLine();\n      }\n\n      this._attachMousedown();\n    },\n\n    /**\n     * Disable this module (remove attached elements and unbind event)\n     */\n    destroy: function() {\n      util.removeElement(this.helperElement);\n      util.removeElement(this.lineElement);\n\n      this._restoreTextSelection();\n      this._detachMousedown();\n    },\n\n    /**\n     * Change helper element position\n     * @param {object} mousePos - Current mouse position\n     * @private\n     */\n    _changeHelperPosition: function(mousePos) {\n      var helperStyle = this.helperElement.style;\n      var pos = this.tree.rootElement.getBoundingClientRect();\n\n      helperStyle.top = mousePos.y - pos.top + this.helperPos.y + 'px';\n      helperStyle.left = mousePos.x - pos.left + this.helperPos.x + 'px';\n      helperStyle.display = '';\n    },\n\n    /**\n     * Init helper element\n     * @private\n     */\n    _initHelper: function() {\n      var helperElement = document.createElement('span');\n      var helperStyle = helperElement.style;\n\n      helperStyle.position = 'absolute';\n      helperStyle.display = 'none';\n\n      util.addClass(helperElement, this.helperClassName);\n\n      this.tree.rootElement.parentNode.appendChild(helperElement);\n\n      this.helperElement = helperElement;\n    },\n\n    /**\n     * Init moving line element\n     * @private\n     */\n    _initMovingLine: function() {\n      var lineElement = document.createElement('div');\n      var lineStyle = lineElement.style;\n\n      lineStyle.position = 'absolute';\n      lineStyle.display = 'none';\n\n      util.addClass(lineElement, this.lineClassName);\n\n      this.tree.rootElement.parentNode.appendChild(lineElement);\n\n      this.lineElement = lineElement;\n    },\n\n    /**\n     * Set helper contents\n     * @param {string} contents - Helper contents\n     * @private\n     */\n    _setHelper: function(contents) {\n      this.helperElement.innerHTML = contents;\n      util.removeElement(this.helperElement.getElementsByTagName('label')[0]);\n    },\n\n    /**\n     * Attach mouse down event\n     * @private\n     */\n    _attachMousedown: function() {\n      this._preventTextSelection();\n      this.tree.on('mousedown', this._onMousedown, this);\n    },\n\n    /**\n     * Detach mousedown event\n     * @private\n     */\n    _detachMousedown: function() {\n      this.tree.off(this);\n    },\n\n    /**\n     * Prevent text-selection\n     * @private\n     */\n    _preventTextSelection: function() {\n      var style = this.tree.rootElement.style;\n\n      util.addEventListener(this.tree.rootElement, 'selectstart', util.preventDefault);\n\n      this.userSelectPropertyKey = selectKey;\n      this.userSelectPropertyValue = style[selectKey];\n\n      style[selectKey] = 'none';\n    },\n\n    /**\n     * Restore text-selection\n     * @private\n     */\n    _restoreTextSelection: function() {\n      util.removeEventListener(this.tree.rootElement, 'selectstart', util.preventDefault);\n\n      if (this.userSelectPropertyKey) {\n        this.tree.rootElement.style[this.userSelectPropertyKey] = this.userSelectPropertyValue;\n      }\n    },\n\n    /**\n     * Return whether the target element is in rejectedTagNames or in rejectedClassNames\n     * @param {HTMLElement} target - Target element\n     * @returns {boolean} Whether the target is not draggable or draggable\n     * @private\n     */\n    _isNotDraggable: function(target) {\n      var tagName = target.tagName.toUpperCase();\n      var classNames = util.getClass(target).split(/\\s+/);\n      var result;\n\n      if (inArray(tagName, this.rejectedTagNames) !== -1) {\n        return true;\n      }\n\n      forEach(\n        classNames,\n        function(className) {\n          result = inArray(className, this.rejectedClassNames) !== -1;\n\n          return !result;\n        },\n        this\n      );\n\n      return result;\n    },\n\n    /**\n     * Event handler - mousedown\n     * @param {MouseEvent} event - Mouse event\n     * @private\n     */\n    _onMousedown: function(event) {\n      var tree = this.tree;\n      var target = util.getTarget(event);\n      var isEditing = tree.enabledFeatures.Editable && tree.enabledFeatures.Editable.inputElement;\n      var nodeElement;\n\n      if (util.isRightButton(event) || this._isNotDraggable(target) || isEditing) {\n        return;\n      }\n\n      util.preventDefault(event);\n\n      this.currentNodeId = tree.getNodeIdFromElement(target);\n\n      if (this.useHelper) {\n        nodeElement = util.getElementsByClassName(\n          document.getElementById(this.currentNodeId),\n          tree.classNames.textClass\n        )[0];\n        this._setHelper(nodeElement.innerHTML);\n      }\n\n      tree.on(\n        {\n          mousemove: this._onMousemove,\n          mouseup: this._onMouseup\n        },\n        this\n      );\n    },\n\n    /**\n     * Event handler - mousemove\n     * @param {MouseEvent} event - Mouse event\n     * @private\n     */\n    _onMousemove: function(event) {\n      var mousePos = util.getMousePos(event);\n      var target = util.getTarget(event);\n      var nodeId;\n\n      if (!this.useHelper) {\n        return;\n      }\n\n      this._setClassNameOnDragItem('add');\n      this._changeHelperPosition(mousePos);\n\n      nodeId = this.tree.getNodeIdFromElement(target);\n\n      if (nodeId) {\n        this._applyMoveAction(nodeId, mousePos);\n      }\n    },\n\n    /**\n     * Event handler - mouseup\n     * @param {MouseEvent} event - Mouse event\n     * @private\n     */\n    _onMouseup: function(event) {\n      var tree = this.tree;\n      var nodeId = this.currentNodeId;\n      var target = util.getTarget(event);\n      var targetId = this._getTargetNodeId(target);\n      var index = this._getIndexToInsert(targetId);\n      var newParentId;\n\n      if (index === -1) {\n        // When the node is created as a child after moving\n        newParentId = targetId;\n      } else {\n        newParentId = tree.getParentId(targetId);\n      }\n\n      if (nodeId !== newParentId) {\n        // Don't fire beforeMove event\n        tree.move(nodeId, newParentId, index);\n      }\n\n      this._reset();\n    },\n\n    /**\n     * Get id of the target element on which the moved item is placed\n     * @param {HTMLElement} target - Target element\n     * @returns {string} Id of target element\n     * @private\n     */\n    _getTargetNodeId: function(target) {\n      var tree = this.tree;\n      var movingType = this.movingLineType;\n      var nodeId = tree.getNodeIdFromElement(target);\n      var childIds;\n\n      if (nodeId) {\n        return nodeId;\n      }\n\n      childIds = tree.getChildIds(tree.getRootNodeId());\n\n      if (movingType === 'top') {\n        nodeId = childIds[0];\n      } else {\n        nodeId = childIds[childIds.length - 1];\n      }\n\n      return nodeId;\n    },\n\n    /**\n     * Get a index number to insert the moved item\n     * @param {number} nodeId - Id of moved item\n     * @returns {number} Index number\n     * @private\n     */\n    _getIndexToInsert: function(nodeId) {\n      var movingType = this.movingLineType;\n      var index;\n\n      if (!movingType) {\n        return -1;\n      }\n\n      index = this.tree.getNodeIndex(nodeId);\n\n      if (movingType === 'bottom') {\n        index += 1;\n      }\n\n      return index;\n    },\n\n    /**\n     * Apply move action that are delay effect and sortable moving node\n     * @param {strig} nodeId - Selected tree node id\n     * @param {object} mousePos - Current mouse position\n     * @private\n     */\n    _applyMoveAction: function(nodeId, mousePos) {\n      var currentElement = document.getElementById(nodeId);\n      var targetPos = currentElement.getBoundingClientRect();\n      var hasClass = util.hasClass(currentElement, this.hoverClassName);\n      var isContain = this._isContain(targetPos, mousePos);\n      var boundaryType;\n\n      if (!this.hoveredElement && isContain) {\n        this.hoveredElement = currentElement;\n        this._hover(nodeId);\n      } else if (!hasClass) {\n        this._unhover();\n      } else if (!isContain) {\n        this._unhover();\n      }\n\n      if (this.isSortable) {\n        boundaryType = this._getBoundaryType(targetPos, mousePos);\n        this._drawBoundaryLine(targetPos, boundaryType);\n      }\n    },\n\n    /**\n     * Act to hover on tree item\n     * @param {string} nodeId - Tree node id\n     * @private\n     */\n    _hover: function(nodeId) {\n      var tree = this.tree;\n\n      util.addClass(this.hoveredElement, this.hoverClassName);\n\n      if (tree.isLeaf(nodeId)) {\n        return;\n      }\n\n      this.timer = setTimeout(function() {\n        tree.open(nodeId);\n      }, this.autoOpenDelay);\n    },\n\n    /**\n     * Act to unhover on tree item\n     * @private\n     */\n    _unhover: function() {\n      clearTimeout(this.timer);\n\n      util.removeClass(this.hoveredElement, this.hoverClassName);\n\n      this.hoveredElement = null;\n      this.timer = null;\n    },\n\n    /**\n     * Check contained state of current target\n     * @param {object} targetPos - Position of tree item\n     * @param {object} mousePos - Position of moved mouse\n     * @returns {boolean} Contained state\n     * @private\n     */\n    _isContain: function(targetPos, mousePos) {\n      var top = targetPos.top;\n      var bottom = targetPos.bottom;\n\n      if (this.isSortable) {\n        top += this.lineBoundary.top;\n        bottom -= this.lineBoundary.bottom;\n      }\n\n      if (\n        targetPos.left < mousePos.x &&\n        targetPos.right > mousePos.x &&\n        top < mousePos.y &&\n        bottom > mousePos.y\n      ) {\n        return true;\n      }\n\n      return false;\n    },\n\n    /**\n     * Get boundary type by mouse position\n     * @param {object} targetPos - Position of tree item\n     * @param {object} mousePos - Position of moved mouse\n     * @returns {string} Position type in boundary\n     * @private\n     */\n    _getBoundaryType: function(targetPos, mousePos) {\n      var type;\n\n      if (mousePos.y < targetPos.top + this.lineBoundary.top) {\n        type = 'top';\n      } else if (mousePos.y > targetPos.bottom - this.lineBoundary.bottom) {\n        type = 'bottom';\n      }\n\n      return type;\n    },\n\n    /**\n     * Draw boundary line on tree\n     * @param {object} targetPos - Position of tree item\n     * @param {string} boundaryType - Position type in boundary\n     * @private\n     */\n    _drawBoundaryLine: function(targetPos, boundaryType) {\n      var style = this.lineElement.style;\n      var scrollTop;\n\n      if (boundaryType) {\n        scrollTop = util.getElementTop(this.tree.rootElement.parentNode);\n        style.top = targetPos[boundaryType] - scrollTop + 'px';\n        style.display = 'block';\n        this.movingLineType = boundaryType;\n      } else {\n        style.display = 'none';\n        this.movingLineType = null;\n      }\n    },\n\n    /**\n     * _reset properties and remove event\n     * @private\n     */\n    _reset: function() {\n      if (this.isSortable) {\n        this.lineElement.style.display = 'none';\n      }\n\n      if (this.hoveredElement) {\n        util.removeClass(this.hoveredElement, this.hoverClassName);\n        this.hoveredElement = null;\n      }\n\n      this._setClassNameOnDragItem('remove');\n\n      this.helperElement.style.display = 'none';\n\n      this.currentNodeId = null;\n      this.movingLineType = null;\n\n      this.tree.off(this, 'mousemove');\n      this.tree.off(this, 'mouseup');\n    },\n\n    /**\n     * Set class name on drag item's element\n     * @param {string} type - Set type ('add' or 'remove')\n     */\n    _setClassNameOnDragItem: function(type) {\n      var dragItemElement = document.getElementById(this.currentNodeId);\n      var dragItemClassName = defaultOptions.dragItemClassName;\n\n      if (type === 'add') {\n        util.addClass(dragItemElement, dragItemClassName);\n      } else {\n        util.removeClass(dragItemElement, dragItemClassName);\n      }\n    }\n  }\n);\n\nmodule.exports = Draggable;\n\n\n//# sourceURL=webpack://tui.Tree/./src/js/features/draggable.js?");

/***/ }),

/***/ "./src/js/features/editable.js":
/*!*************************************!*\
  !*** ./src/js/features/editable.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @fileoverview Feature that each tree node is possible to edit as double click\n * @author NHN. FE dev Lab <dl_javascript@nhn.com>\n */\nvar util = __webpack_require__(/*! ./../util */ \"./src/js/util.js\");\nvar ajaxCommand = __webpack_require__(/*! ./../consts/ajaxCommand */ \"./src/js/consts/ajaxCommand.js\");\nvar states = __webpack_require__(/*! ./../consts/states */ \"./src/js/consts/states.js\");\nvar snippet = __webpack_require__(/*! tui-code-snippet */ \"tui-code-snippet\");\n\nvar API_LIST = ['createChildNode', 'editNode', 'finishEditing'];\nvar EDIT_TYPE = {\n  CREATE: 'create',\n  UPDATE: 'update'\n};\nvar WRAPPER_CLASSNAME = 'tui-input-wrap';\nvar INPUT_CLASSNAME = 'tui-tree-input';\n\n/**\n * Set the tree selectable\n * @class Editable\n * @param {Tree} tree - Tree\n * @param {Object} options - Options\n *  @param {string} options.editableClassName - Classname of editable element\n *  @param {string} options.dataKey - Key of node data to set value\n *  @param {string} [options.dataValue] - Value of node data to set value (Use \"createNode\" API)\n *  @param {string} [options.inputClassName] - Classname of input element\n * @ignore\n */\nvar Editable = snippet.defineClass(\n  /** @lends Editable.prototype */ {\n    static: {\n      /**\n       * @static\n       * @memberof Selectable\n       * @returns {Array.<string>} API list of Editable\n       */\n      getAPIList: function() {\n        return API_LIST.slice();\n      }\n    },\n    init: function(tree, options) {\n      options = snippet.extend({}, options);\n\n      /**\n       * Tree\n       * @type {Tree}\n       */\n      this.tree = tree;\n\n      /**\n       * Classname of editable element\n       * @type {string}\n       */\n      this.editableClassName = options.editableClassName || tree.classNames.textClass;\n\n      /**\n       * Key of node data to set value\n       * @type {string}\n       */\n      this.dataKey = options.dataKey;\n\n      /**\n       * Default value for creating node\n       * @type {string}\n       */\n      this.defaultValue = options.defaultValue || '';\n\n      /**\n       * Input element for create or edit\n       * @type {HTMLElement}\n       */\n      this.inputElement = null;\n\n      /**\n       * Action mode - create or edit\n       * @type {string}\n       */\n      this.mode = null;\n\n      /**\n       * For block blur when unintentional blur event occur when alert popup\n       * @type {Boolean}\n       */\n      this._blockBlur = false;\n\n      /**\n       * Keyup event handler\n       * @type {Function}\n       */\n      this.boundOnKeyup = snippet.bind(this._onKeyup, this);\n\n      /**\n       * Blur event handler\n       * @type {Function}\n       */\n      this.boundOnBlur = snippet.bind(this._onBlur, this);\n\n      tree.on('doubleClick', this._onDoubleClick, this);\n\n      this._setAPIs();\n    },\n\n    /**\n     * Disable this module\n     */\n    destroy: function() {\n      var tree = this.tree;\n\n      this._detachInputElement();\n      tree.off(this);\n      snippet.forEach(API_LIST, function(apiName) {\n        delete tree[apiName];\n      });\n    },\n\n    /**\n     * Create child node\n     * @memberof Tree.prototype\n     * @requires Editable\n     * @param {string} parentId - Parent node id to create new node\n     * @example\n     * tree.createChildNode('tui-tree-node-1');\n     */\n    createChildNode: function(parentId) {\n      var tree = this.tree;\n      var useAjax = tree.enabledFeatures.Ajax;\n      var nodeId;\n\n      this.mode = EDIT_TYPE.CREATE;\n\n      if (useAjax) {\n        tree.on('successAjaxResponse', this._onSuccessResponse, this);\n      }\n\n      if (!tree.isLeaf(parentId) && tree.getState(parentId) === states.node.CLOSED) {\n        tree.open(parentId);\n      } else {\n        nodeId = tree._add({}, parentId)[0];\n        this._attachInputElement(nodeId);\n      }\n    },\n\n    /**\n     * Edit node\n     * @memberof Tree.prototype\n     * @requires Editable\n     * @param {string} nodeId - Node id\n     * @example\n     * tree.editNode('tui-tree-node-1');\n     */\n    editNode: function(nodeId) {\n      this.mode = EDIT_TYPE.UPDATE;\n      this._attachInputElement(nodeId);\n    },\n\n    /**\n     * Exit edit though remove input tag\n     * @memberof Tree.prototype\n     * @requires Editable\n     * @example\n     * tree.finishEditing();\n     */\n    finishEditing: function() {\n      if (this.inputElement) {\n        this._detachInputElement();\n      }\n    },\n\n    /**\n     * Custom event handler \"successResponse\"\n     * @param {string} type - Ajax command type\n     * @param {Array.<string>} nodeIds - Added node ids on tree\n     * @private\n     */\n    _onSuccessResponse: function(type, nodeIds) {\n      var tree = this.tree;\n      var parentId, nodeId;\n\n      if (type === ajaxCommand.READ && nodeIds) {\n        parentId = tree.getParentId(nodeIds[0]);\n        nodeId = tree._add({}, parentId)[0];\n        this._attachInputElement(nodeId);\n      }\n    },\n\n    /**\n     * Custom event handler \"doubleClick\"\n     * @param {MouseEvent} event - Mouse event\n     * @private\n     */\n    _onDoubleClick: function(event) {\n      var target = util.getTarget(event);\n      var nodeId;\n\n      if (util.hasClass(target, this.editableClassName)) {\n        nodeId = this.tree.getNodeIdFromElement(target);\n        this.editNode(nodeId);\n      }\n    },\n\n    /**\n     * InputElement is keep going\n     * @private\n     */\n    _keepEdit: function() {\n      if (this.inputElement) {\n        this.inputElement.focus();\n      }\n    },\n\n    /**\n     * Invoke 'beforeCreateChildNode'\n     * @param {Object} event - Information of 'beforeCreateChildNode'\n     * @returns {boolean} Result of invoke event\n     * @private\n     */\n    _invokeBeforeCreateChildNode: function(event) {\n      /**\n       * @event Tree#beforeCreateChildNode\n       * @type {object} evt - Event data\n       * @property {string} value - Return value of creating input element\n       * @property {string} nodeId - Return id of creating node\n       * @property {string} cause - Return 'blur' or 'enter' according cause of the event\n       * @example\n       * tree\n       *  .enableFeature('Editable')\n       *  .on('beforeCreateChildNode', function(evt) {\n       *      console.log(evt.value);\n       *      console.log(evt.nodeId);\n       *      console.log(evt.cause);\n       *      return false; // It cancels\n       *      // return true; // It execute next\n       *  });\n       */\n      return this.tree.invoke('beforeCreateChildNode', event);\n    },\n\n    /**\n     * Invoke 'beforeEditNode'\n     * @param {Event} event - Information of 'beforeEditNode'\n     * @returns {boolean} Result of invoke event\n     * @private\n     */\n    _invokeBeforeEditNode: function(event) {\n      /**\n       * @event Tree#beforeEditNode\n       * @type {object} evt - Event data\n       * @property {string} value - Return value of creating input element\n       * @property {string} nodeId - Return id of editing node\n       * @property {string} cause - Return 'blur' or 'enter' according cause of the event\n       * @example\n       * tree\n       *  .enableFeature('Editable')\n       *  .on('beforeEditNode', function(evt) {\n       *      console.log(evt.value);\n       *      console.log(evt.nodeId);\n       *      console.log(evt.cause);\n       *      return false; // It cancels\n       *      // return true; // It execute next\n       *  });\n       */\n      return this.tree.invoke('beforeEditNode', event);\n    },\n\n    /**\n     * Reflect the value of inputElement to node for creating or editing\n     * @param {string} cause - how finish editing ('blur' or 'enter')\n     * @returns {boolean} Result of submit input result\n     * @private\n     */\n    _submitInputResult: function(cause) {\n      var tree = this.tree;\n      var nodeId = tree.getNodeIdFromElement(this.inputElement);\n      var value = this.inputElement.value;\n      var event = {\n        value: value,\n        nodeId: nodeId,\n        cause: cause\n      };\n\n      if (this.mode === EDIT_TYPE.CREATE) {\n        if (!this._invokeBeforeCreateChildNode(event)) {\n          this._keepEdit();\n\n          return false;\n        }\n        this._addData(nodeId, value);\n      } else {\n        if (!this._invokeBeforeEditNode(event)) {\n          this._keepEdit();\n\n          return false;\n        }\n        this._setData(nodeId, value);\n      }\n      this._detachInputElement();\n\n      return true;\n    },\n\n    /**\n     * Event handler: keyup - input element\n     * @param {Event} event - Key event\n     * @private\n     */\n    _onKeyup: function(event) {\n      if (util.getKeyCode(event) === 13) {\n        this._blockBlur = true;\n        this._submitInputResult('enter');\n      }\n    },\n\n    /**\n     * Event handler: blur - input element\n     * @private\n     */\n    _onBlur: function() {\n      if (this._blockBlur) {\n        this._blockBlur = false;\n      } else {\n        this._blockBlur = !this._submitInputResult('blur');\n      }\n    },\n\n    /**\n     * Create input element\n     * @returns {HTMLElement} Input element\n     * @private\n     */\n    _createInputElement: function() {\n      var element = document.createElement('INPUT');\n      element.setAttribute('type', 'text');\n      util.addClass(element, INPUT_CLASSNAME);\n\n      return element;\n    },\n\n    /**\n     * Attach input element on tree\n     * @param {string} nodeId - Node id\n     * @private\n     */\n    _attachInputElement: function(nodeId) {\n      var tree = this.tree;\n      var target = document.getElementById(nodeId);\n      var wrapperElement = document.createElement('DIV');\n      var inputElement = this._createInputElement();\n\n      if (!target) {\n        return;\n      }\n\n      wrapperElement = util.getChildElementByClassName(target, WRAPPER_CLASSNAME);\n\n      if (!wrapperElement) {\n        wrapperElement = document.createElement('DIV');\n        inputElement = this._createInputElement();\n\n        util.addClass(wrapperElement, WRAPPER_CLASSNAME);\n        wrapperElement.style.paddingLeft = tree.getIndentWidth(nodeId) + 'px';\n\n        inputElement.value = tree.getNodeData(nodeId)[this.dataKey] || '';\n\n        wrapperElement.appendChild(inputElement);\n        target.appendChild(wrapperElement);\n\n        util.addEventListener(inputElement, 'keyup', this.boundOnKeyup);\n        util.addEventListener(inputElement, 'blur', this.boundOnBlur);\n\n        if (this.inputElement) {\n          this.inputElement.blur();\n        }\n        this.inputElement = inputElement;\n      }\n\n      this._blockBlur = false;\n      this.inputElement.focus();\n    },\n\n    /**\n     * Detach input element on tree\n     * @private\n     */\n    _detachInputElement: function() {\n      var tree = this.tree;\n      var inputElement = this.inputElement;\n      var wrapperElement = this.inputElement.parentNode;\n\n      util.removeEventListener(inputElement, 'keyup', this.boundOnKeyup);\n      util.removeEventListener(inputElement, 'blur', this.boundOnBlur);\n\n      util.removeElement(wrapperElement);\n\n      if (tree.enabledFeatures.Ajax) {\n        tree.off(this, 'successAjaxResponse');\n      }\n\n      this.inputElement = null;\n    },\n\n    /**\n     * Add data of input element to node and detach input element on tree\n     * @param {string} nodeId - Node id to add\n     * @param {string} value - Content for that node\n     * @private\n     */\n    _addData: function(nodeId, value) {\n      var tree = this.tree;\n      var parentId = tree.getParentId(nodeId);\n      var data = {};\n\n      if (nodeId) {\n        data[this.dataKey] = value || this.defaultValue;\n        tree._remove(nodeId);\n        tree.add(data, parentId);\n      }\n    },\n\n    /**\n     * Set data of input element to node and detach input element on tree\n     * @param {string} nodeId - Node id to change\n     * @param {string} value - Content for that node\n     * @private\n     */\n    _setData: function(nodeId, value) {\n      var tree = this.tree;\n      var data = {};\n\n      if (nodeId) {\n        data[this.dataKey] = value;\n        tree.setNodeData(nodeId, data);\n      }\n    },\n\n    /**\n     * Set apis of selectable tree\n     * @private\n     */\n    _setAPIs: function() {\n      var tree = this.tree;\n      var bind = snippet.bind;\n\n      snippet.forEach(\n        API_LIST,\n        function(apiName) {\n          tree[apiName] = bind(this[apiName], this);\n        },\n        this\n      );\n    }\n  }\n);\n\nmodule.exports = Editable;\n\n\n//# sourceURL=webpack://tui.Tree/./src/js/features/editable.js?");

/***/ }),

/***/ "./src/js/features/selectable.js":
/*!***************************************!*\
  !*** ./src/js/features/selectable.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @fileoverview Feature that each tree node is possible to select as click\n * @author NHN. FE dev Lab <dl_javascript@nhn.com>\n */\nvar util = __webpack_require__(/*! ./../util */ \"./src/js/util.js\");\nvar snippet = __webpack_require__(/*! tui-code-snippet */ \"tui-code-snippet\");\n\nvar API_LIST = ['select', 'getSelectedNodeId', 'deselect'],\n  defaults = {\n    selectedClassName: 'tui-tree-selected'\n  };\n\n/**\n * Set the tree selectable\n * @class Selectable\n * @param {Tree} tree - Tree\n * @param {Object} options\n *  @param {string} options.selectedClassName - Classname for selected node.\n * @ignore\n */\nvar Selectable = snippet.defineClass(\n  /** @lends Selectable.prototype */ {\n    static: {\n      /**\n       * @static\n       * @memberof Selectable\n       * @returns {Array.<string>} API list of Selectable\n       */\n      getAPIList: function() {\n        return API_LIST.slice();\n      }\n    },\n    init: function(tree, options) {\n      options = snippet.extend({}, defaults, options);\n\n      this.tree = tree;\n      this.selectedClassName = options.selectedClassName;\n      this.selectedNodeId = null;\n\n      tree.on(\n        {\n          singleClick: this.onSingleClick,\n          afterDraw: this.onAfterDraw\n        },\n        this\n      );\n      this._setAPIs();\n    },\n\n    /**\n     * Set apis of selectable tree\n     * @private\n     */\n    _setAPIs: function() {\n      var tree = this.tree,\n        bind = snippet.bind;\n\n      snippet.forEach(\n        API_LIST,\n        function(apiName) {\n          tree[apiName] = bind(this[apiName], this);\n        },\n        this\n      );\n    },\n\n    /**\n     * Disable this module\n     */\n    destroy: function() {\n      var tree = this.tree,\n        nodeElement = this.getPrevElement();\n\n      util.removeClass(nodeElement, this.selectedClassName);\n      tree.off(this);\n      snippet.forEach(API_LIST, function(apiName) {\n        delete tree[apiName];\n      });\n    },\n\n    /**\n     * Custom event handler \"singleClick\"\n     * @param {MouseEvent} event - Mouse event\n     */\n    onSingleClick: function(event) {\n      var target = util.getTarget(event),\n        nodeId = this.tree.getNodeIdFromElement(target);\n\n      this.select(nodeId, target);\n    },\n\n    /* eslint-disable valid-jsdoc */\n    /* Ignore \"target\" parameter annotation for API page\n       \"tree.select(nodeId)\"\n     */\n\n    /**\n     * Select node if the feature-\"Selectable\" is enabled.\n     * @memberof Tree.prototype\n     * @requires Selectable\n     * @param {string} nodeId - Node id\n     * @example\n     * tree.select('tui-tree-node-3');\n     */\n    select: function(nodeId, target) {\n      /* eslint-enable valid-jsdoc */\n      var tree, prevElement, nodeElement, selectedClassName, prevNodeId;\n\n      if (!nodeId) {\n        return;\n      }\n\n      tree = this.tree;\n      prevElement = this.getPrevElement();\n      nodeElement = document.getElementById(nodeId);\n      selectedClassName = this.selectedClassName;\n      prevNodeId = this.selectedNodeId;\n\n      /**\n       * @event Tree#beforeSelect\n       * @type {object} evt - Event data\n       * @property {string} nodeId - Selected node id\n       * @property {string} prevNodeId - Previous selected node id\n       * @property {HTMLElement|undefined} target - Target element\n       * @example\n       * tree\n       *  .enableFeature('Selectable')\n       *  .on('beforeSelect', function(evt) {\n       *      console.log('selected node: ' + evt.nodeId);\n       *      console.log('previous selected node: ' + evt.prevNodeId);\n       *      console.log('target element: ' + evt.target);\n       *      return false; // It cancels \"select\"\n       *      // return true; // It fires \"select\"\n       *  });\n       */\n      if (\n        tree.invoke('beforeSelect', {\n          nodeId: nodeId,\n          prevNodeId: prevNodeId,\n          target: target\n        })\n      ) {\n        util.removeClass(prevElement, selectedClassName);\n        util.addClass(nodeElement, selectedClassName);\n\n        /**\n         * @event Tree#select\n         * @type {object} evt - Event data\n         * @property {string} nodeId - Selected node id\n         * @property {string} prevNodeId - Previous selected node id\n         * @property {HTMLElement|undefined} target - Target element\n         * @example\n         * tree\n         *  .enableFeature('Selectable')\n         *  .on('select', function(evt) {\n         *      console.log('selected node: ' + evt.nodeId);\n         *      console.log('previous selected node: ' + evt.prevNodeId);\n         *      console.log('target element: ' + evt.target);\n         *  });\n         */\n        tree.fire('select', {\n          nodeId: nodeId,\n          prevNodeId: prevNodeId,\n          target: target\n        });\n        this.selectedNodeId = nodeId;\n      }\n    },\n\n    /**\n     * Get previous selected node element\n     * @returns {HTMLElement} Node element\n     */\n    getPrevElement: function() {\n      return document.getElementById(this.selectedNodeId);\n    },\n\n    /**\n     * Get selected node id\n     * @memberof Tree.prototype\n     * @returns {string} selected node id\n     */\n    getSelectedNodeId: function() {\n      return this.selectedNodeId;\n    },\n\n    /**\n     * Deselect node by id\n     * @memberof Tree.prototype\n     * @requires Selectable\n     * @param {string} nodeId - Node id\n     * @example\n     * tree.deselect('tui-tree-node-3');\n     */\n    deselect: function() {\n      var nodeId = this.selectedNodeId;\n      var nodeElement = document.getElementById(nodeId);\n      var tree = this.tree;\n\n      if (!nodeElement) {\n        return;\n      }\n\n      util.removeClass(nodeElement, this.selectedClassName);\n      this.selectedNodeId = null;\n\n      /**\n       * @event Tree#deselect\n       * @type {object} evt - Event data\n       * @property {string} nodeId - Deselected node id\n       * @example\n       * tree\n       *  .enableFeature('Selectable')\n       *  .on('deselect', function(evt) {\n       *      console.log('deselected node: ' + evt.nodeId);\n       *  });\n       */\n      tree.fire('deselect', {nodeId: nodeId});\n    },\n\n    /**\n     * Custom event handler - \"afterDraw\"\n     */\n    onAfterDraw: function() {\n      var nodeElement = this.getPrevElement();\n\n      if (nodeElement) {\n        util.addClass(nodeElement, this.selectedClassName);\n      }\n    }\n  }\n);\n\nmodule.exports = Selectable;\n\n\n//# sourceURL=webpack://tui.Tree/./src/js/features/selectable.js?");

/***/ }),

/***/ "./src/js/index.js":
/*!*************************!*\
  !*** ./src/js/index.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ../css/tree.css */ \"./src/css/tree.css\");\n\nmodule.exports = __webpack_require__(/*! ./tree */ \"./src/js/tree.js\");\n\n\n//# sourceURL=webpack://tui.Tree/./src/js/index.js?");

/***/ }),

/***/ "./src/js/tree.js":
/*!************************!*\
  !*** ./src/js/tree.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @fileoverview Render tree and update tree\n * @author NHN. FE dev Lab <dl_javascript@nhn.com>\n */\n\nvar util = __webpack_require__(/*! ./util */ \"./src/js/util.js\");\nvar defaultOption = __webpack_require__(/*! ./consts/defaultOption */ \"./src/js/consts/defaultOption.js\");\nvar states = __webpack_require__(/*! ./consts/states */ \"./src/js/consts/states.js\");\nvar messages = __webpack_require__(/*! ./consts/messages */ \"./src/js/consts/messages.js\");\nvar outerTemplate = __webpack_require__(/*! ./consts/outerTemplate */ \"./src/js/consts/outerTemplate.js\");\nvar ajaxCommand = __webpack_require__(/*! ./consts/ajaxCommand */ \"./src/js/consts/ajaxCommand.js\");\nvar TreeModel = __webpack_require__(/*! ./treeModel */ \"./src/js/treeModel.js\");\nvar Selectable = __webpack_require__(/*! ./features/selectable */ \"./src/js/features/selectable.js\");\nvar Draggable = __webpack_require__(/*! ./features/draggable */ \"./src/js/features/draggable.js\");\nvar Editable = __webpack_require__(/*! ./features/editable */ \"./src/js/features/editable.js\");\nvar Checkbox = __webpack_require__(/*! ./features/checkbox */ \"./src/js/features/checkbox.js\");\nvar ContextMenu = __webpack_require__(/*! ./features/contextMenu */ \"./src/js/features/contextMenu.js\");\nvar Ajax = __webpack_require__(/*! ./features/ajax */ \"./src/js/features/ajax.js\");\n\nvar nodeStates = states.node;\nvar features = {\n  Selectable: Selectable,\n  Draggable: Draggable,\n  Editable: Editable,\n  Checkbox: Checkbox,\n  ContextMenu: ContextMenu,\n  Ajax: Ajax\n};\nvar snippet = __webpack_require__(/*! tui-code-snippet */ \"tui-code-snippet\");\nvar extend = snippet.extend;\n\nvar TIMEOUT_TO_DIFFERENTIATE_CLICK_AND_DBLCLICK = 200;\nvar MOUSE_MOVING_THRESHOLD = 5;\n\n/**\n * Create tree model and inject data to model\n * @class Tree\n * @param {string|HTMLElement|jQueryObject} container - Tree container element or id string value\n * @param {Object} options The options\n *     @param {Object} [options.data] A data to be used on tree\n *     @param {string} [options.nodeIdPrefix] A default prefix of a node\n *     @param {Object} [options.nodeDefaultState] A default state of a node\n *     @param {Object} [options.stateLabels] Toggle button state label\n *         @param {string} [options.stateLabels.opened] State-OPENED label\n *         @param {string} [options.stateLabels.closed] State-CLOSED label\n *     @param {Object} [options.template] A markup set to make element\n *         @param {string} [options.template.internalNode] HTML template\n *         @param {string} [options.template.leafNode] HTML template\n *     @param {Function} [options.renderTemplate] Function for rendering template\n *     @param {boolean} [options.usageStatistics=true] - Let us know the hostname. If you don't want to send the hostname, please set to false.\n * @example <caption>Get `Tree` module</caption>\n * // * node, commonjs\n * // * Get Tree module from `node_modules/tui-tree`\n * var Tree = require('tui-tree');\n * var instance = new Tree(...);\n * // * distribution file, script\n * // * there is `tui.Tree` as a global variable\n * var Tree = tui.Tree;\n * var instance = new Tree(...);\n * @example <caption>Initialize Tree</caption>\n * // Default options:\n * // {\n * //     data: [],\n * //     nodeIdPrefix: 'tui-tree-node-',\n * //     nodeDefaultState: 'closed',\n * //     stateLabels: {\n * //         opened: '-',\n * //         closed: '+'\n * //     },\n * //     template: {\n * //         internalNode:\n * //             '<div class=\"tui-tree-content-wrapper\">' +\n * //                 '<button type=\"button\" class=\"tui-tree-toggle-btn tui-js-tree-toggle-btn\">' +\n * //                     '<span class=\"tui-ico-tree\"></span>' +\n * //                     '{{stateLabel}}' +\n * //                 '</button>' +\n * //                 '<span class=\"tui-tree-text tui-js-tree-text\">' +\n * //                     '<span class=\"tui-tree-ico tui-ico-folder\"></span>' +\n * //                     '{{text}}' +\n * //                 '</span>' +\n * //             '</div>' +\n * //             '<ul class=\"tui-tree-subtree tui-js-tree-subtree\">' +\n * //                 '{{children}}' +\n * //             '</ul>',\n * //         leafNode:\n * //             '<div class=\"tui-tree-content-wrapper\">' +\n * //                 '<span class=\"tui-tree-text tui-js-tree-text\">' +\n * //                     '<span class=\"tui-tree-ico tui-ico-file\"></span>' +\n * //                     '{{text}}' +\n * //                 '</span>' +\n * //             '</div>'\n * //     }\n * // }\n * var container = document.getElementById('tree');\n * var data = [\n *     {text: 'rootA', children: [\n *         {text: 'root-1A'},\n *         {text: 'root-1B'},\n *         {text: 'root-1C'},\n *         {text: 'root-1D'},\n *         {text: 'root-2A', children: [\n *             {text: 'sub_1A', children:[\n *                 {text: 'sub_sub_1A'}\n *             ]},\n *             {text: 'sub_2A'}\n *         ]},\n *         {text: 'root-2B'},\n *         {text: 'root-2C'},\n *         {text: 'root-2D'},\n *         {text: 'root-3A', children: [\n *             {text: 'sub3_a'},\n *             {text: 'sub3_b'}\n *         ]},\n *         {text: 'root-3B'},\n *         {text: 'root-3C'},\n *         {text: 'root-3D'}\n *     ]},\n *     {text: 'rootB', children: [\n *         {text: 'B_sub1'},\n *         {text: 'B_sub2'},\n *         {text: 'b'}\n *     ]}\n * ];\n * var tree = new Tree(container, {\n *     data: data,\n *     nodeDefaultState: 'opened',\n *\n *     // ========= Option: Override template renderer ===========\n *\n *     template: { // template for Mustache engine\n *         internalNode:\n *             '<div class=\"tui-tree-content-wrapper\">' +\n *                 '<button type=\"button\" class=\"tui-tree-toggle-btn tui-js-tree-toggle-btn\">' +\n *                     '<span class=\"tui-ico-tree\"></span>' +\n *                     '{{stateLabel}}' +\n *                 '</button>' +\n *                 '<span class=\"tui-tree-text tui-js-tree-text\">' +\n *                     '<span class=\"tui-tree-ico tui-ico-folder\"></span>' +\n *                     '{{text}}' +\n *                 '</span>' +\n *             '</div>' +\n *             '<ul class=\"tui-tree-subtree tui-js-tree-subtree\">' +\n *                  '{{{children}}}' +\n *             '</ul>',\n *         leafNode:\n *             '<div class=\"tui-tree-content-wrapper\">' +\n *                 '<span class=\"tui-tree-text tui-js-tree-text\">' +\n *                     '<span class=\"tui-tree-ico tui-ico-file\"></span>' +\n *                     '{{text}}' +\n *                 '</span>' +\n *             '</div>'\n *     },\n *     renderTemplate: function(tmpl, props) {\n *         // Mustache template engine\n *         return Mustache.render(tmpl, props);\n *     }\n * });\n */\nvar Tree = snippet.defineClass(\n  /** @lends Tree.prototype */ {\n    init: function(container, options) {\n      options = extend({}, defaultOption, options);\n\n      /**\n       * Default class names\n       * @type {object.<string, string>}\n       */\n      this.classNames = extend({}, defaultOption.classNames, options.classNames);\n\n      /**\n       * Default template\n       * @type {{internalNode: string, leafNode: string}}\n       */\n      this.template = extend({}, defaultOption.template, options.template);\n\n      /**\n       * Root element\n       * @type {HTMLElement}\n       */\n      this.rootElement = null;\n\n      /**\n       * Toggle button state label\n       * @type {{opened: string, closed: string}}\n       */\n      this.stateLabels = options.stateLabels;\n\n      /**\n       * Make tree model\n       * @type {TreeModel}\n       * @private\n       */\n      this.model = new TreeModel(options);\n\n      /**\n       * Enabled features\n       * @type {Object.<string, object>}\n       * @private\n       */\n      this.enabledFeatures = {};\n\n      /**\n       * Click timer to prevent click-duplication with double click\n       * @type {number}\n       * @private\n       */\n      this.clickTimer = null;\n\n      /**\n       * To prevent click event if mouse moved before mouseup.\n       * @type {number}\n       * @private\n       */\n      this._mouseMovingFlag = false;\n\n      /**\n       * Render template\n       * It can be overrode by user's template engine.\n       * @type {Function}\n       * @private\n       */\n      this._renderTemplate = options.renderTemplate || util.renderTemplate;\n\n      /**\n       * Send the hostname to google analytics.\n       * If you do not want to send the hostname, this option set to false.\n       * @type {boolean}\n       * @private\n       */\n      this.usageStatistics = options.usageStatistics;\n\n      /**\n       * True when a node is moving\n       * @type {boolean}\n       * @example\n       * tree.on({\n       *     beforeDraw: function(nodeId) {\n       *         if (tree.isMovingNode) {\n       *             return;\n       *         }\n       *         //..\n       *     },\n       *     //....\n       * });\n       * tree.move('tui-tree-node-1', 'tui-tree-node-2');\n       */\n      this.isMovingNode = false;\n\n      /**\n       * Indentation value\n       * @type {number}\n       * @private\n       */\n      this._indent = options.indent;\n\n      this._setRoot(container);\n      this._draw(this.getRootNodeId());\n      this._setEvents();\n\n      if (this.usageStatistics) {\n        util.sendHostName();\n      }\n    },\n\n    /**\n     * Set root element of tree\n     * @param {string|HTMLElement|jQueryObject} container - Container element or id selector\n     * @private\n     */\n    _setRoot: function(container) {\n      var rootElement = outerTemplate.ROOT;\n\n      if (snippet.isString(container)) {\n        container = document.getElementById(container);\n      } else if (container.jquery) {\n        container = container[0];\n      }\n\n      if (!snippet.isHTMLNode(container)) {\n        throw new Error(messages.INVALID_CONTAINER_ELEMENT);\n      }\n\n      container.innerHTML = rootElement;\n      this.rootElement = container.firstChild;\n    },\n\n    /**\n     * Move event handler\n     * @param {string} nodeId - Node id\n     * @param {string} originalParentId - Original parent node id\n     * @param {string} newParentId - New parent node id\n     * @param {number} [index] - Start index number for inserting\n     * @private\n     */\n    _onMove: function(nodeId, originalParentId, newParentId, index) {\n      this._draw(originalParentId);\n      this._draw(newParentId);\n\n      /**\n       * @event Tree#move\n       * @type {object} evt - Event data\n       * @property {string} nodeId - Current node id to move\n       * @property {string} originalParentId - Original parent node id of moved node\n       * @property {string} newParentId - New parent node id of moved node\n       * @property {number} index - Moved index number\n       * @example\n       * tree.on('move', function(evt) {\n       *     var nodeId = evt.nodeId;\n       *     var originalParentId = evt.originalParentId;\n       *     var newParentId = evt.newParentId;\n       *     var index = evt.index;\n       *\n       *     console.log(nodeId, originalParentId, newParentId, index);\n       * });\n       */\n      this.fire('move', {\n        nodeId: nodeId,\n        originalParentId: originalParentId,\n        newParentId: newParentId,\n        index: index\n      });\n    },\n\n    /**\n     * Set event handlers\n     * @private\n     */\n    _setEvents: function() {\n      this.model.on(\n        {\n          update: this._draw,\n          move: this._onMove\n        },\n        this\n      );\n      util.addEventListener(this.rootElement, 'click', snippet.bind(this._onClick, this));\n      util.addEventListener(this.rootElement, 'mousedown', snippet.bind(this._onMousedown, this));\n      util.addEventListener(this.rootElement, 'dblclick', snippet.bind(this._onDoubleClick, this));\n      util.addEventListener(\n        this.rootElement,\n        'contextmenu',\n        snippet.bind(this._onContextMenu, this)\n      );\n    },\n\n    /**\n     * Event handler - contextmenu\n     * @param {MouseEvent} mouseEvent - Contextmenu event\n     * @private\n     */\n    _onContextMenu: function(mouseEvent) {\n      this.fire('contextmenu', mouseEvent);\n    },\n\n    /**\n     * Event handler - mousedown\n     * @param {MouseEvent} downEvent - Mouse event\n     * @private\n     */\n    _onMousedown: function(downEvent) {\n      var self = this,\n        clientX = downEvent.clientX,\n        clientY = downEvent.clientY,\n        abs = Math.abs;\n\n      /* eslint-disable require-jsdoc */\n      function onMouseMove(moveEvent) {\n        var newClientX = moveEvent.clientX,\n          newClientY = moveEvent.clientY;\n\n        if (abs(newClientX - clientX) + abs(newClientY - clientY) > MOUSE_MOVING_THRESHOLD) {\n          self.fire('mousemove', moveEvent);\n          self._mouseMovingFlag = true;\n        }\n      }\n\n      function onMouseUp(upEvent) {\n        self.fire('mouseup', upEvent);\n        util.removeEventListener(document, 'mousemove', onMouseMove);\n        util.removeEventListener(document, 'mouseup', onMouseUp);\n        util.removeEventListener(document, 'mouseout', onMouseOut);\n      }\n\n      function onMouseOut(event) {\n        if (event.toElement === null) {\n          self.fire('mouseup', event);\n        }\n      }\n      /* eslint-enable require-jsdoc */\n\n      this._mouseMovingFlag = false;\n      this.fire('mousedown', downEvent);\n      util.addEventListener(document, 'mousemove', onMouseMove);\n      util.addEventListener(document, 'mouseup', onMouseUp);\n      util.addEventListener(document, 'mouseout', onMouseOut);\n    },\n\n    /**\n     * Event handler - click\n     * @param {MouseEvent} event - Click event\n     * @private\n     */\n    _onClick: function(event) {\n      var target = util.getTarget(event);\n      var self = this;\n      var nodeId;\n\n      if (util.isRightButton(event)) {\n        this.clickTimer = null;\n\n        return;\n      }\n\n      if (this._isClickedToggleButton(target)) {\n        nodeId = this.getNodeIdFromElement(target);\n\n        this.toggle(nodeId);\n\n        /**\n         * @event Tree#clickToggleBtn\n         * @type {object} evt - Event data\n         * @property {string} nodeId - Node id\n         * @property {HTMLElement} target - Element of toggle button\n         * @example\n         * tree.on('clickToggleBtn', function(evt) {\n         *     console.log(evt.target);\n         * });\n         */\n        this.fire('clickToggleBtn', {\n          nodeId: nodeId,\n          target: target\n        });\n\n        return;\n      }\n\n      if (!this.clickTimer && !this._mouseMovingFlag) {\n        this.fire('singleClick', event);\n        this.clickTimer = setTimeout(function() {\n          self.resetClickTimer();\n        }, TIMEOUT_TO_DIFFERENTIATE_CLICK_AND_DBLCLICK);\n      }\n    },\n\n    /**\n     * Event handler - double click (dblclick)\n     * @param {MouseEvent} event - Double click event\n     * @private\n     */\n    _onDoubleClick: function(event) {\n      this.fire('doubleClick', event);\n      this.resetClickTimer();\n    },\n\n    /**\n     * Whether target element is toggle button or not\n     * @param {HTMLElement} target - Tree node element\n     * @returns {boolean} State\n     * @private\n     */\n    _isClickedToggleButton: function(target) {\n      var nodeId = this.getNodeIdFromElement(target);\n      var nodeElement;\n\n      if (!nodeId) {\n        return false;\n      }\n\n      nodeElement = util.getElementsByClassName(\n        document.getElementById(nodeId),\n        this.classNames.toggleBtnClass\n      )[0];\n\n      return nodeElement && nodeElement.contains(target);\n    },\n\n    /**\n     * Set node state - opened or closed\n     * @param {string} nodeId - Node id\n     * @param {string} state - Node state\n     * @private\n     */\n    _setDisplayFromNodeState: function(nodeId, state) {\n      var subtreeElement = this._getSubtreeElement(nodeId),\n        label,\n        btnElement,\n        nodeElement,\n        firstTextNode;\n\n      if (!subtreeElement || subtreeElement === this.rootElement) {\n        return;\n      }\n      label = this.stateLabels[state];\n      nodeElement = document.getElementById(nodeId);\n\n      btnElement = util.getElementsByClassName(nodeElement, this.classNames.toggleBtnClass)[0];\n\n      if (state === nodeStates.OPENED) {\n        subtreeElement.style.display = '';\n      } else {\n        subtreeElement.style.display = 'none';\n      }\n      this._setNodeClassNameFromState(nodeElement, state);\n\n      if (btnElement) {\n        firstTextNode = util.getFirstTextNode(btnElement);\n        firstTextNode.nodeValue = label;\n      }\n    },\n\n    /**\n     * Set node class name from provided state\n     * @param {HTMLElement} nodeElement - TreeNode element\n     * @param {string} state - New changed state\n     * @private\n     */\n    _setNodeClassNameFromState: function(nodeElement, state) {\n      var classNames = this.classNames,\n        openedClassName = classNames[nodeStates.OPENED + 'Class'],\n        closedClassName = classNames[nodeStates.CLOSED + 'Class'];\n\n      util.removeClass(nodeElement, openedClassName);\n      util.removeClass(nodeElement, closedClassName);\n      util.addClass(nodeElement, classNames[state + 'Class']);\n    },\n\n    /**\n     * Make html\n     * @param {Array.<string>} nodeIds - Node id list\n     * @returns {string} HTML\n     * @private\n     * @see outerTemplate uses \"util.renderTemplate\"\n     */\n    _makeHtml: function(nodeIds) {\n      var model = this.model,\n        html = '';\n\n      snippet.forEach(\n        nodeIds,\n        function(nodeId) {\n          var node = model.getNode(nodeId),\n            sources,\n            props;\n\n          if (!node) {\n            return;\n          }\n\n          sources = this._getTemplate(node);\n          props = this._makeTemplateProps(node);\n          props.innerTemplate = this._makeInnerHTML(node, {\n            source: sources.inner,\n            props: props\n          });\n          html += util.renderTemplate(sources.outer, props);\n        },\n        this\n      );\n\n      return html;\n    },\n\n    /**\n     * Make inner html of node\n     * @param {TreeNode} node - Node\n     * @param {{source: string, props: Object}} [cached] - Cashed data to make html\n     * @returns {string} Inner html of node\n     * @private\n     * @see innerTemplate uses \"this._renderTemplate\"\n     */\n    _makeInnerHTML: function(node, cached) {\n      var source, props;\n\n      cached = cached || {};\n      source = cached.source || this._getTemplate(node).inner;\n      props = cached.props || this._makeTemplateProps(node);\n\n      return this._renderTemplate(source, props);\n    },\n\n    /**\n     * Get template sources\n     * @param {TreeNode} node - Node\n     * @returns {{inner: string, outer: string}} Template sources\n     * @private\n     */\n    _getTemplate: function(node) {\n      var source;\n\n      if (node.isLeaf()) {\n        source = {\n          inner: this.template.leafNode,\n          outer: outerTemplate.LEAF_NODE\n        };\n      } else {\n        source = {\n          inner: this.template.internalNode,\n          outer: outerTemplate.INTERNAL_NODE\n        };\n      }\n\n      return source;\n    },\n\n    /**\n     * Make template properties\n     * @param {TreeNode} node - Node\n     * @returns {Object} Template properties\n     * @private\n     */\n    _makeTemplateProps: function(node) {\n      var classNames = this.classNames,\n        id = node.getId(),\n        props = {\n          id: id,\n          indent: this.getIndentWidth(id)\n        },\n        state;\n\n      if (node.isLeaf()) {\n        extend(props, {\n          isLeaf: true // for custom template method\n        });\n      } else {\n        state = node.getState();\n        extend(props, {\n          stateClass: classNames[state + 'Class'],\n          stateLabel: this.stateLabels[state],\n          children: this._makeHtml(node.getChildIds())\n        });\n      }\n\n      return extend(props, classNames, node.getAllData());\n    },\n\n    /**\n     * calculate tree node's padding left\n     * @param {string} nodeId - Node id\n     * @returns {number} - padding left of tree node division\n     */\n    getIndentWidth: function(nodeId) {\n      return this.getDepth(nodeId) * this._indent;\n    },\n\n    /**\n     * Draw element of node\n     * @param {string} nodeId - Node id\n     * @private\n     */\n    _draw: function(nodeId) {\n      var node = this.model.getNode(nodeId),\n        element,\n        html;\n\n      if (!node) {\n        return;\n      }\n\n      /**\n       * @event Tree#beforeDraw\n       * @type {object} evt - Event data\n       * @property {string} nodeId - Node id\n       * @example\n       * tree.on('beforeDraw', function(evt) {\n       *     if (tree.isMovingNode) {\n       *         console.log('isMovingNode');\n       *     }\n       *     console.log('beforeDraw: ' + evt.nodeId);\n       * });\n       */\n      this.fire('beforeDraw', {nodeId: nodeId});\n\n      if (node.isRoot()) {\n        html = this._makeHtml(node.getChildIds());\n        element = this.rootElement;\n      } else {\n        html = this._makeInnerHTML(node);\n        element = document.getElementById(nodeId);\n      }\n      element.innerHTML = html;\n      this._setClassNameAndVisibilityByFeature(node);\n\n      /**\n       * @event Tree#afterDraw\n       * @type {object} evt - Event data\n       * @property {string} nodeId - Node id\n       * @example\n       * tree.on('afterDraw', function(evt) {\n       *     if (tree.isMovingNode) {\n       *         console.log('isMovingNode');\n       *     }\n       *     console.log('afterDraw: ' + evt.nodeId);\n       * });\n       */\n      this.fire('afterDraw', {nodeId: nodeId});\n    },\n\n    /**\n     * Update class name by features on below<br>\n     * - leaf node: has classNames.leafClass<br>\n     * - internal node + opened: has classNames.openedClass, child is visible<br>\n     * - internal node + closed: has classNames.closedClass, child is not visible<br>\n     * @param {TreeNode} node - (re)drawing starts from this node\n     * @private\n     */\n    _setClassNameAndVisibilityByFeature: function(node) {\n      var nodeId = node.getId(),\n        element = document.getElementById(nodeId),\n        classNames = this.classNames;\n\n      if (node.isLeaf()) {\n        util.removeClass(element, classNames.openedClass);\n        util.removeClass(element, classNames.closedClass);\n        util.addClass(element, classNames.leafClass);\n      } else {\n        util.removeClass(element, classNames.leafClass);\n        this._setDisplayFromNodeState(nodeId, node.getState());\n        this.each(\n          function(child) {\n            this._setClassNameAndVisibilityByFeature(child);\n          },\n          nodeId,\n          this\n        );\n      }\n    },\n\n    /**\n     * Get subtree element\n     * @param {string} nodeId - TreeNode id\n     * @returns {HTMLElement} Subtree element\n     * @private\n     */\n    _getSubtreeElement: function(nodeId) {\n      var node = this.model.getNode(nodeId),\n        subtreeElement;\n\n      if (!node || node.isLeaf()) {\n        subtreeElement = null;\n      } else if (node.isRoot()) {\n        subtreeElement = this.rootElement;\n      } else {\n        subtreeElement = util.getElementsByClassName(\n          document.getElementById(nodeId),\n          this.classNames.subtreeClass\n        )[0];\n      }\n\n      return subtreeElement;\n    },\n\n    /**\n     * Return the depth of node\n     * @param {string} nodeId - Node id\n     * @returns {number|undefined} Depth\n     */\n    getDepth: function(nodeId) {\n      return this.model.getDepth(nodeId);\n    },\n\n    /**\n     * Return the last depth of tree\n     * @returns {number} Last depth\n     */\n    getLastDepth: function() {\n      return this.model.getLastDepth();\n    },\n\n    /**\n     * Return root node id\n     * @returns {string} Root node id\n     */\n    getRootNodeId: function() {\n      return this.model.rootNode.getId();\n    },\n\n    /**\n     * Return child ids\n     * @param {string} nodeId - Node id\n     * @returns {Array.<string>|undefined} Child ids\n     */\n    getChildIds: function(nodeId) {\n      return this.model.getChildIds(nodeId);\n    },\n\n    /**\n     * Return parent id of node\n     * @param {string} nodeId - Node id\n     * @returns {string|undefined} Parent id\n     */\n    getParentId: function(nodeId) {\n      return this.model.getParentId(nodeId);\n    },\n\n    /**\n     * Reset click timer\n     */\n    resetClickTimer: function() {\n      window.clearTimeout(this.clickTimer);\n      this.clickTimer = null;\n    },\n\n    /**\n     * Get node id from element\n     * @param {HTMLElement} element - Element\n     * @returns {string} Node id\n     * @example\n     * tree.getNodeIdFromElement(elementInNode); // 'tui-tree-node-3'\n     */\n    getNodeIdFromElement: function(element) {\n      var idPrefix = this.getNodeIdPrefix();\n\n      while (element && element.id.indexOf(idPrefix) === -1) {\n        element = element.parentElement;\n      }\n\n      return element ? element.id : '';\n    },\n\n    /**\n     * Get prefix of node id\n     * @returns {string} Prefix of node id\n     * @example\n     * tree.getNodeIdPrefix(); // 'tui-tree-node-'\n     */\n    getNodeIdPrefix: function() {\n      return this.model.getNodeIdPrefix();\n    },\n\n    /**\n     * Get node data\n     * @param {string} nodeId - Node id\n     * @returns {object|undefined} Node data\n     */\n    getNodeData: function(nodeId) {\n      return this.model.getNodeData(nodeId);\n    },\n\n    /**\n     * Set data properties of a node\n     * @param {string} nodeId - Node id\n     * @param {object} data - Properties\n     * @param {object} [options] - Options\n     *     @param {boolean} [options.isSilent] - If true, it doesn't trigger the 'update' event\n     *     @param {boolean} [options.useAjax] - State of using Ajax\n     * @exmaple\n     * tree.setNodeData(nodeId, {foo: 'bar'}); // auto refresh\n     * tree.setNodeData(nodeId, {foo: 'bar'}, true); // not refresh\n     */\n    setNodeData: function(nodeId, data, options) {\n      var self = this;\n      var treeAjax = this.enabledFeatures.Ajax;\n      var useAjax = options ? options.useAjax : !!treeAjax;\n      var isSilent = options ? options.isSilent : false;\n\n      if (useAjax) {\n        treeAjax.loadData(\n          ajaxCommand.UPDATE,\n          function() {\n            self._setNodeData(nodeId, data);\n          },\n          {\n            nodeId: nodeId,\n            data: data,\n            type: 'set'\n          }\n        );\n      } else {\n        this._setNodeData(nodeId, data, isSilent);\n      }\n    },\n\n    /**\n     * Set data properties of a node (Core method)\n     * @param {string} nodeId - Node id\n     * @param {object} data - Properties\n     * @param {boolean} [isSilent] - If true, it doesn't trigger the 'update' event\n     * @private\n     */\n    _setNodeData: function(nodeId, data, isSilent) {\n      this.model.setNodeData(nodeId, data, isSilent);\n    },\n\n    /**\n     * Remove node data\n     * @param {string} nodeId - Node id\n     * @param {string|Array} names - Names of properties\n     * @param {object} [options] - Options\n     *     @param {boolean} [options.isSilent] - If true, it doesn't trigger the 'update' event\n     *     @param {boolean} [options.useAjax] - State of using Ajax\n     * @example\n     * tree.setNodeData(nodeId, 'foo'); // auto refresh\n     * tree.setNodeData(nodeId, 'foo', true); // not refresh\n     */\n    removeNodeData: function(nodeId, names, options) {\n      var self = this;\n      var treeAjax = this.enabledFeatures.Ajax;\n      var useAjax = options ? options.useAjax : !!treeAjax;\n      var isSilent = options ? options.isSilent : false;\n\n      if (useAjax) {\n        treeAjax.loadData(\n          ajaxCommand.UPDATE,\n          function() {\n            self._removeNodeData(nodeId, names);\n          },\n          {\n            nodeId: nodeId,\n            names: names,\n            type: 'remove'\n          }\n        );\n      } else {\n        this._removeNodeData(nodeId, names, isSilent);\n      }\n    },\n\n    /**\n     * Remove node data (Core method)\n     * @param {string} nodeId - Node id\n     * @param {string|Array} names - Names of properties\n     * @param {boolean} [isSilent] - If true, it doesn't trigger the 'update' event\n     * @private\n     */\n    _removeNodeData: function(nodeId, names, isSilent) {\n      this.model.removeNodeData(nodeId, names, isSilent);\n    },\n\n    /**\n     * Get node state.\n     * @param {string} nodeId - Node id\n     * @returns {string|null} Node state(('opened', 'closed', null)\n     * @example\n     * tree.getState(nodeId); // 'opened', 'closed',\n     *                        // undefined if the node is nonexistent\n     */\n    getState: function(nodeId) {\n      var node = this.model.getNode(nodeId);\n\n      if (!node) {\n        return null;\n      }\n\n      return node.getState();\n    },\n    /**\n     * Open node\n     * @param {string} nodeId - Node id\n     * @param {boolean} recursive - If true, it open all parent (default: false)\n     * @example\n     * tree.open(nodeId ,true);\n     */\n    open: function(nodeId, recursive) {\n      if (recursive) {\n        this._openRecursiveNode(nodeId);\n      } else {\n        this._openNode(nodeId);\n      }\n    },\n    /**\n     * Open all parent node\n     * @param {string} nodeId - Node id\n     * @private\n     */\n    _openRecursiveNode: function(nodeId) {\n      var parentIds = this.model.getParentIds(nodeId);\n      parentIds.push(nodeId);\n      snippet.forEach(\n        parentIds,\n        function(parentId) {\n          this._openNode(parentId);\n        },\n        this\n      );\n    },\n    /**\n     * Open one target node\n     * @param {string} nodeId - Node id\n     * @private\n     */\n    _openNode: function(nodeId) {\n      var node = this.model.getNode(nodeId);\n      var state = nodeStates.OPENED;\n      var isAllowStateChange = node && !node.isRoot() && node.getState() === nodeStates.CLOSED;\n\n      if (isAllowStateChange) {\n        node.setState(state);\n        this._setDisplayFromNodeState(nodeId, state);\n      }\n\n      if (this.enabledFeatures.Ajax) {\n        this._reload(nodeId);\n      }\n    },\n\n    /**\n     * Close node\n     * @param {string} nodeId - Node id\n     * @param {boolean} recursive - If true, it close all child node (default: false)\n     * @example\n     * tree.close(nodeId, true);\n     */\n    close: function(nodeId, recursive) {\n      if (recursive) {\n        this._closeRecursiveNode(nodeId);\n      } else {\n        this._closeNode(nodeId);\n      }\n    },\n\n    /**\n     * Close all child node\n     * @param {string} nodeId - Node id\n     * @private\n     */\n    _closeRecursiveNode: function(nodeId) {\n      this._closeNode(nodeId);\n      this.model.each(\n        function(searchNode, searchNodeId) {\n          if (!searchNode.isLeaf()) {\n            this._closeNode(searchNodeId);\n          }\n        },\n        nodeId,\n        this\n      );\n    },\n\n    /**\n     * Close one target node\n     * @param {string} nodeId - Node id\n     * @private\n     */\n    _closeNode: function(nodeId) {\n      var node = this.model.getNode(nodeId);\n      var state = nodeStates.CLOSED;\n      var isAllowStateChange = node && !node.isRoot() && node.getState() === nodeStates.OPENED;\n      if (isAllowStateChange) {\n        node.setState(state);\n        this._setDisplayFromNodeState(nodeId, state);\n      }\n    },\n\n    /**\n     * Toggle node\n     * @param {string} nodeId - Node id\n     */\n    toggle: function(nodeId) {\n      var node = this.model.getNode(nodeId);\n      var state;\n\n      if (!node || node.isRoot()) {\n        return;\n      }\n\n      node.toggleState();\n      state = node.getState();\n      this._setDisplayFromNodeState(nodeId, state);\n\n      if (this.enabledFeatures.Ajax) {\n        this._reload(nodeId);\n      }\n    },\n\n    /**\n     * Reload children nodes while \"stateLable\" is clicked\n     * @param {string} nodeId - Node id\n     * @private\n     */\n    _reload: function(nodeId) {\n      var node = this.model.getNode(nodeId);\n      var state = node.getState();\n      var isReload = snippet.isUndefined(node.getData('reload')) || node.getData('reload');\n\n      if (state === nodeStates.CLOSED) {\n        // open -> close action\n        this._setNodeData(\n          nodeId,\n          {\n            reload: false\n          },\n          true\n        );\n      }\n\n      if (state === nodeStates.OPENED && isReload) {\n        // close -> open action\n        this.resetAllData(null, {\n          nodeId: nodeId,\n          useAjax: true\n        });\n      }\n    },\n\n    /**\n     * Sort all nodes\n     * @param {Function} comparator - Comparator for sorting\n     * @param {boolean} [isSilent] - If true, it doesn't redraw tree\n     * @param {string} [parentId] - Id of a node to sort partially\n     * @example\n     * var comparator = function(nodeA, nodeB) {\n     *     var aValue = nodeA.getData('text'),\n     *         bValue = nodeB.getData('text');\n     *\n     *     if (!bValue || !bValue.localeCompare) {\n     *         return 0;\n     *     }\n     *     return bValue.localeCompare(aValue);\n     * };\n     *\n     * // Sort with redrawing tree\n     * tree.sort(comparator);\n     *\n     * // Sort, but not redraw tree\n     * tree.sort(comparator, true);\n     *\n     * // Sort partially\n     * tree.sort(comparator, false, parentId)\n     */\n    sort: function(comparator, isSilent, parentId) {\n      this.model.sort(comparator, parentId);\n\n      if (!isSilent) {\n        this.refresh(parentId);\n      }\n    },\n\n    /**\n     * Refresh tree or node's children\n     * @param {string} [nodeId] - TreeNode id to refresh\n     */\n    refresh: function(nodeId) {\n      nodeId = nodeId || this.getRootNodeId();\n      this._draw(nodeId);\n    },\n\n    /**\n     * Traverse this tree iterating over all nodes.\n     * @param {Function} iteratee - Iteratee function\n     * @param {object} [context] - Context of iteratee\n     * @example\n     * tree.eachAll(function(node, nodeId) {\n     *     console.log(node.getId() === nodeId); // true\n     * });\n     */\n    eachAll: function(iteratee, context) {\n      this.model.eachAll(iteratee, context);\n    },\n\n    /**\n     * Traverse this tree iterating over all descendants of a node.\n     * @param {Function} iteratee - Iteratee function\n     * @param {string} parentId - Parent node id\n     * @param {object} [context] - Context of iteratee\n     * @example\n     * tree.each(function(node, nodeId) {\n     *     console.log(node.getId() === nodeId); // true\n     * }, parentId);\n     *\n     */\n    each: function(iteratee, parentId, context) {\n      this.model.each(iteratee, parentId, context);\n    },\n\n    /**\n     * Add node(s).\n     * - If the parentId is falsy, the node will be appended to rootNode.\n     * - If 'isSilent' is not true, it redraws the tree\n     * @param {Array|object} data - Raw-data\n     * @param {*} [parentId] - Parent id\n     * @param {object} [options] - Options\n     *     @param {boolean} [options.isSilent] - If true, it doesn't redraw children\n     *     @param {boolean} [options.useAjax] - State of using Ajax\n     * @returns {?Array.<string>} Added node ids\n     * @example\n     * // add node with redrawing\n     * var firstAddedIds = tree.add({text:'FE development team1'}, parentId);\n     * console.log(firstAddedIds); // [\"tui-tree-node-10\"]\n     *\n     * // add node without redrawing\n     * var secondAddedIds = tree.add([\n     *    {text: 'FE development team2'},\n     *    {text: 'FE development team3'}\n     * ], parentId, true);\n     * console.log(secondAddedIds); // [\"tui-tree-node-11\", \"tui-tree-node-12\"]\n     */\n    add: function(data, parentId, options) {\n      var self = this;\n      var treeAjax = this.enabledFeatures.Ajax;\n      var useAjax = options ? options.useAjax : !!treeAjax;\n      var isSilent = options ? options.isSilent : false;\n      var newChildIds;\n\n      if (useAjax) {\n        treeAjax.loadData(\n          ajaxCommand.CREATE,\n          function() {\n            return self._add(data, parentId);\n          },\n          {\n            parentId: parentId,\n            data: data\n          }\n        );\n      } else {\n        newChildIds = this._add(data, parentId, isSilent);\n      }\n\n      return newChildIds;\n    },\n\n    /**\n     * Add node(s). (Core method)\n     * - If the parentId is falsy, the node will be appended to rootNode.\n     * - If 'isSilent' is not true, it redraws the tree\n     * @param {Array|object} data - Raw-data\n     * @param {*} [parentId] - Parent id\n     * @param {boolean} [isSilent] - If true, it doesn't redraw children\n     * @returns {Array.<string>} Added node ids\n     * @private\n     */\n    _add: function(data, parentId, isSilent) {\n      return this.model.add(data, parentId, isSilent);\n    },\n\n    /**\n     * Reset all data\n     * @param {Array|object} data - Raw data for all nodes\n     * @param {object} [options] - Options\n     *     @param {string} [options.nodeId] - Parent node id to reset all child data\n     *     @param {boolean} [options.useAjax] - State of using Ajax\n     * @returns {?Array.<string>} Added node ids\n     * @example\n     * tree.resetAllData([\n     *  {text: 'hello', children: [\n     *      {text: 'foo'},\n     *      {text: 'bar'}\n     *  ]},\n     *  {text: 'world'}\n     * ]);\n     * tree.resetAllData([\n     *  {text: 'hello world'}\n     * ], {\n     *  nodeId: 'tui-tree-node-5',\n     *  useAjax: true\n     * });\n     */\n    resetAllData: function(data, options) {\n      var self = this;\n      var treeAjax = this.enabledFeatures.Ajax;\n      var nodeId = options ? options.nodeId : this.getRootNodeId();\n      var useAjax = options ? options.useAjax : !!treeAjax;\n      var newChildIds;\n\n      if (useAjax) {\n        treeAjax.loadData(\n          ajaxCommand.READ,\n          function(response) {\n            return self._resetAllData(response, nodeId);\n          },\n          {\n            nodeId: nodeId\n          }\n        );\n      } else {\n        newChildIds = this._resetAllData(data, nodeId);\n      }\n\n      return newChildIds;\n    },\n\n    /**\n     * Reset all data (Core method)\n     * @param {Array|object} data - Raw data for all nodes\n     * @param {string} nodeId - Node id to reset data\n     * @returns {Array.<string>} Added node ids\n     * @private\n     */\n    _resetAllData: function(data, nodeId) {\n      this._removeAllChildren(nodeId, {\n        isSilent: true\n      });\n\n      return this._add(data, nodeId);\n    },\n\n    /**\n     * Remove all children\n     * @param {string} nodeId - Parent node id\n     * @param {object} [options] - Options\n     *     @param {boolean} [options.isSilent] - If true, it doesn't redraw the node\n     *     @param {boolean} [options.useAjax] - State of using Ajax\n     * @example\n     * tree.removeAllChildren(nodeId); // Redraws the node\n     * tree.removeAllChildren(nodId, true); // Doesn't redraw the node\n     */\n    removeAllChildren: function(nodeId, options) {\n      var self = this;\n      var treeAjax = this.enabledFeatures.Ajax;\n      var useAjax = options ? options.useAjax : !!treeAjax;\n      var isSilent = options ? options.isSilent : false;\n\n      if (useAjax) {\n        treeAjax.loadData(\n          ajaxCommand.DELETE_ALL_CHILDREN,\n          function() {\n            self._removeAllChildren(nodeId);\n          },\n          {\n            parentId: nodeId\n          }\n        );\n      } else {\n        this._removeAllChildren(nodeId, isSilent);\n      }\n    },\n\n    /**\n     * Remove all children (Core method)\n     * @param {string} nodeId - Parent node id\n     * @param {boolean} [isSilent] - If true, it doesn't redraw the node\n     * @private\n     */\n    _removeAllChildren: function(nodeId, isSilent) {\n      var children = this.getChildIds(nodeId);\n\n      snippet.forEach(\n        children,\n        function(childId) {\n          this._remove(childId, true);\n        },\n        this\n      );\n\n      if (!isSilent) {\n        this._draw(nodeId);\n      }\n    },\n\n    /**\n     * Remove a node with children.\n     * - If 'isSilent' is not true, it redraws the tree\n     * @param {string} nodeId - Node id to remove\n     * @param {object} [options] - Options\n     *     @param {boolean} [options.isSilent] - If true, it doesn't redraw children\n     *     @param {boolean} [options.useAjax] - State of using Ajax\n     * @example\n     * tree.remove(myNodeId); // remove node with redrawing\n     * tree.remove(myNodeId, true); // remove node without redrawing\n     */\n    remove: function(nodeId, options) {\n      var self = this;\n      var treeAjax = this.enabledFeatures.Ajax;\n      var useAjax = options ? options.useAjax : !!treeAjax;\n      var isSilent = options ? options.isSilent : false;\n\n      if (useAjax) {\n        treeAjax.loadData(\n          ajaxCommand.DELETE,\n          function() {\n            self._remove(nodeId);\n          },\n          {\n            nodeId: nodeId\n          }\n        );\n      } else {\n        this._remove(nodeId, isSilent);\n      }\n    },\n\n    /**\n     * Remove a node with children. (Core method)\n     * - If 'isSilent' is not true, it redraws the tree\n     * @param {string} nodeId - Node id to remove\n     * @param {boolean} [isSilent] - If true, it doesn't redraw children\n     * @private\n     */\n    _remove: function(nodeId, isSilent) {\n      this.model.remove(nodeId, isSilent);\n    },\n\n    /**\n     * Move a node to new parent\n     * - If 'isSilent' is not true, it redraws the tree\n     * @param {string} nodeId - Node id\n     * @param {string} newParentId - New parent id\n     * @param {number} index - Index number of selected node\n     * @param {object} [options] - Options\n     *     @param {boolean} [options.isSilent] - If true, it doesn't trigger the 'update' event\n     *     @param {boolean} [options.useAjax] - State of using Ajax\n     * @example\n     * tree.move(myNodeId, newParentId); // mode node with redrawing\n     * tree.move(myNodeId, newParentId, true); // move node without redrawing\n     */\n    move: function(nodeId, newParentId, index, options) {\n      var self = this;\n      var treeAjax = this.enabledFeatures.Ajax;\n      var useAjax = options ? options.useAjax : !!treeAjax;\n      var isSilent = options ? options.isSilent : false;\n\n      if (useAjax) {\n        treeAjax.loadData(\n          ajaxCommand.MOVE,\n          function() {\n            if (self.getParentId(nodeId) !== newParentId) {\n              // just move, not sort!\n              self.setNodeData(\n                newParentId,\n                {\n                  reload: true\n                },\n                true\n              );\n            }\n            self._move(nodeId, newParentId, index);\n          },\n          {\n            nodeId: nodeId,\n            newParentId: newParentId,\n            index: index\n          }\n        );\n      } else {\n        this._move(nodeId, newParentId, index, isSilent);\n      }\n    },\n\n    /**\n     * Move a node to new parent (Core method)\n     * - If 'isSilent' is not true, it redraws the tree\n     * @param {string} nodeId - Node id\n     * @param {string} newParentId - New parent id\n     * @param {number} index - Index number of selected node\n     * @param {boolean} [isSilent] - If true, it doesn't redraw children\n     * @private\n     */\n    _move: function(nodeId, newParentId, index, isSilent) {\n      /**\n       * @event Tree#beforeMove\n       * @type {object} evt - Event data\n       * @property {string} nodeId - Current dragging node id\n       * @property {string} newParentId - New parent id\n       * @example\n       * tree.on('beforeMove', function(evt) {\n       *      console.log('dragging node: ' + evt.nodeId);\n       *      console.log('new parent node: ' + evt.newParentId);\n       *      console.log('original parent node: ' + tree.getParentId(evt.nodeId));\n       *\n       *      return false; // Cancel \"move\" event\n       *      // return true; // Fire \"move\" event\n       * });\n       */\n      if (\n        !this.invoke('beforeMove', {\n          nodeId: nodeId,\n          newParentId: newParentId\n        })\n      ) {\n        return;\n      }\n\n      this.isMovingNode = true;\n      this.model.move(nodeId, newParentId, index, isSilent);\n      this.isMovingNode = false;\n    },\n\n    /**\n     * Search node ids by passing the predicate check or matching data\n     * @param {Function|Object} predicate - Predicate or data\n     * @param {Object} [context] - Context of predicate\n     * @returns {Array.<string>} Node ids\n     * @example\n     * // search from predicate\n     * var leafNodeIds = tree.search(function(node, nodeId) {\n     *     return node.isLeaf();\n     * });\n     * console.log(leafNodeIds); // ['tui-tree-node-3', 'tui-tree-node-5']\n     *\n     * // search from data\n     * var specialNodeIds = tree.search({\n     *     isSpecial: true,\n     *     foo: 'bar'\n     * });\n     * console.log(specialNodeIds); // ['tui-tree-node-5', 'tui-tree-node-10']\n     * console.log(tree.getNodeData('tui-tree-node-5').isSpecial); // true\n     * console.log(tree.getNodeData('tui-tree-node-5').foo); // 'bar'\n     */\n    search: function(predicate, context) {\n      if (!snippet.isObject(predicate)) {\n        return [];\n      }\n\n      if (snippet.isFunction(predicate)) {\n        return this._filter(predicate, context);\n      }\n\n      return this._where(predicate);\n    },\n\n    /**\n     * Search node ids by matching data\n     * @param {Object} props - Data\n     * @returns {Array.<string>} Node ids\n     * @private\n     */\n    _where: function(props) {\n      return this._filter(function(node) {\n        var result = true,\n          data = node.getAllData();\n\n        snippet.forEach(props, function(value, key) {\n          result = key in data && data[key] === value;\n\n          return result;\n        });\n\n        return result;\n      });\n    },\n\n    /**\n     * Search node ids by passing the predicate check\n     * @param {Function} predicate - Predicate\n     * @param {Object} [context] - Context of predicate\n     * @returns {Array.<string>} Node ids\n     * @private\n     */\n    _filter: function(predicate, context) {\n      var filtered = [];\n\n      this.eachAll(function(node, nodeId) {\n        if (predicate(node, nodeId)) {\n          filtered.push(nodeId);\n        }\n      }, context);\n\n      return filtered;\n    },\n\n    /**\n     * Whether the node is leaf\n     * @param {string} nodeId - Node id\n     * @returns {boolean} True if the node is leaf.\n     */\n    isLeaf: function(nodeId) {\n      var node = this.model.getNode(nodeId);\n\n      return node && node.isLeaf();\n    },\n\n    /**\n     * Whether a node is a ancestor of another node.\n     * @param {string} containerNodeId - Id of a node that may contain the other node\n     * @param {string} containedNodeId - Id of a node that may be contained by the other node\n     * @returns {boolean} Whether a node contains another node\n     */\n    contains: function(containerNodeId, containedNodeId) {\n      return this.model.contains(containerNodeId, containedNodeId);\n    },\n\n    /**\n     * Enable facility of tree\n     * @param {string} featureName - 'Selectable', 'Draggable', 'Editable', 'ContextMenu'\n     * @param {object} [options] - Feature options\n     * @returns {Tree} this\n     * @example\n     * tree\n     *  .enableFeature('Selectable', {\n     *      selectedClassName: 'tui-tree-selected'\n     *  })\n     *  .enableFeature('Editable', {\n     *      enableClassName: tree.classNames.textClass,\n     *      dataKey: 'text',\n     *      defaultValue: 'new node',\n     *      inputClassName: 'myInput'\n     *  })\n     *  .enableFeature('Draggable', {\n     *      useHelper: true,\n     *      helperPos: {x: 5, y: 2},\n     *      rejectedTagNames: ['UL', 'INPUT', 'BUTTON'],\n     *      rejectedClassNames: ['notDraggable', 'notDraggable-2'],\n     *      autoOpenDelay: 1500,\n     *      isSortable: true,\n     *      hoverClassName: 'tui-tree-hover'\n     *      lineClassName: 'tui-tree-line',\n     *      lineBoundary: {\n     *          top: 10,\n     *          bottom: 10\n     *      }\n     *  })\n     *  .enableFeature('Checkbox', {\n     *      checkboxClassName: 'tui-tree-checkbox'\n     *  })\n     *  .enableFeature('ContextMenu', {\n     *      menuData: [\n     *          {title: 'menu1', command: 'copy'},\n     *          {title: 'menu2', command: 'paste'},\n     *          {separator: true},\n     *          {\n     *              title: 'menu3',\n     *              menu: [\n     *                  {title: 'submenu1'},\n     *                  {title: 'submenu2'}\n     *              ]\n     *          }\n     *      }\n     *  })\n     *  .enableFeature('Ajax', {\n     *      command: {\n     *          read: {\n     *              url: 'api/read',\n     *              dataType: 'json',\n     *              type: 'get'\n     *          },\n     *          create: {\n     *              url: 'api/create',\n     *              dataType: 'json',\n     *              type: 'post'\n     *          },\n     *          update: {\n     *              url: 'api/update',\n     *              dataType: 'json',\n     *              type: 'post',\n     *              data: {\n     *                  paramA: 'a',\n     *                  paramB: 'b'\n     *              }\n     *          },\n     *          remove: {\n     *              url: 'api/remove',\n     *              dataType: 'json',\n     *              type: 'post',\n     *              data: function(params) {\n     *                  return {\n     *                      paramA: params.a,\n     *                      paramB: params.b\n     *                  };\n     *              }\n     *          },\n     *          removeAllChildren: {\n     *              url: function(params) {\n     *                  return 'api/remove_all/' + params.nodeId,\n     *              },\n     *              dataType: 'json',\n     *              type: 'post'\n     *          },\n     *          move: {\n     *              url: 'api/move',\n     *              dataType: 'json',\n     *              type: 'post'\n     *          }\n     *      },\n     *      parseData: function(type, response) {\n     *          if (type === 'read' && response.code === '200') {\n     *              return response;\n     *          } else {\n     *              return false;\n     *          }\n     *      }\n     *  });\n     */\n    enableFeature: function(featureName, options) {\n      var Feature = features[featureName];\n\n      if (!Feature) {\n        return this;\n      }\n\n      this.disableFeature(featureName);\n\n      if (snippet.isObject(options)) {\n        options.usageStatistics = this.usageStatistics;\n      } else {\n        options = {\n          usageStatistics: this.usageStatistics\n        };\n      }\n\n      this.enabledFeatures[featureName] = new Feature(this, options);\n      this.fire('initFeature');\n\n      return this;\n    },\n\n    /**\n     * Disable facility of tree\n     * @param {string} featureName - 'Selectable', 'Draggable', 'Editable'\n     * @returns {Tree} this\n     * @example\n     * tree\n     *  .disableFeature('Selectable')\n     *  .disableFeature('Draggable')\n     *  .disableFeature('Editable')\n     *  .disableFeature('Checkbox')\n     *  .disableFeature('ContextMenu')\n     *  .disableFeature('Ajax');\n     */\n    disableFeature: function(featureName) {\n      var feature = this.enabledFeatures[featureName];\n\n      if (feature) {\n        feature.destroy();\n        delete this.enabledFeatures[featureName];\n      }\n\n      return this;\n    },\n\n    /**\n     * Get index number of selected node\n     * @param {string} nodeId - Id of selected node\n     * @returns {number} Index number of attached node\n     */\n    getNodeIndex: function(nodeId) {\n      var parentId = this.model.getParentId(nodeId);\n\n      return this.model.getNode(parentId).getChildIndex(nodeId);\n    }\n  }\n);\n\n/**\n * Set abstract apis to tree prototype\n * @param {string} featureName - Feature name\n * @param {object} feature - Feature\n * @ignore\n */\nfunction setAbstractAPIs(featureName, feature) {\n  var messageName = 'INVALID_API_' + featureName.toUpperCase(),\n    apiList = feature.getAPIList ? feature.getAPIList() : [];\n\n  snippet.forEach(apiList, function(api) {\n    Tree.prototype[api] = function() {\n      throw new Error(messages[messageName] || messages.INVALID_API);\n    };\n  });\n}\nsnippet.forEach(features, function(Feature, name) {\n  setAbstractAPIs(name, Feature);\n});\nsnippet.CustomEvents.mixin(Tree);\n\nmodule.exports = Tree;\n\n\n//# sourceURL=webpack://tui.Tree/./src/js/tree.js?");

/***/ }),

/***/ "./src/js/treeModel.js":
/*!*****************************!*\
  !*** ./src/js/treeModel.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @fileoverview Update view and control tree data\n * @author NHN. FE dev Lab <dl_javascript@nhn.com>\n */\nvar TreeNode = __webpack_require__(/*! ./treeNode */ \"./src/js/treeNode.js\");\nvar snippet = __webpack_require__(/*! tui-code-snippet */ \"tui-code-snippet\");\n\nvar extend = snippet.extend,\n  keys = snippet.keys,\n  forEach = snippet.forEach,\n  map = snippet.map;\n\n/**\n * Tree model\n * @class TreeModel\n * @param {Array} data - Data\n * @param {Object} options - Options for defaultState and nodeIdPrefix\n * @ignore\n */\nvar TreeModel = snippet.defineClass(\n  /** @lends TreeModel.prototype */ {\n    init: function(options) {\n      TreeNode.setIdPrefix(options.nodeIdPrefix);\n\n      /**\n       * Default state of node\n       * @type {String}\n       */\n      this.nodeDefaultState = options.nodeDefaultState;\n\n      /**\n       * Root node\n       * @type {TreeNode}\n       */\n      this.rootNode = new TreeNode(\n        {\n          state: 'opened'\n        },\n        null\n      );\n\n      /**\n       * Tree hash having all nodes\n       * @type {object.<string, TreeNode>}\n       */\n      this.treeHash = {};\n\n      this._setData(options.data);\n    },\n\n    /**\n     * Return prefix of node id\n     * @returns {string} Prefix\n     */\n    getNodeIdPrefix: function() {\n      return TreeNode.idPrefix;\n    },\n\n    /**\n     * Set model with tree data\n     * @param {Array} data - Tree data\n     */\n    _setData: function(data) {\n      var root = this.rootNode,\n        rootId = root.getId();\n\n      this.treeHash[rootId] = root;\n      this._makeTreeHash(data, root);\n    },\n\n    /**\n     * Make tree hash from data and parentNode\n     * @param {Array} data - Tree data\n     * @param {TreeNode} parent - Parent node id\n     * @returns {Array.<string>} Added node ids\n     * @private\n     */\n    _makeTreeHash: function(data, parent) {\n      var parentId = parent.getId(),\n        ids = [];\n\n      forEach(\n        data,\n        function(datum) {\n          var childrenData = datum.children,\n            node = this._createNode(datum, parentId),\n            nodeId = node.getId();\n\n          ids.push(nodeId);\n          this.treeHash[nodeId] = node;\n          parent.addChildId(nodeId);\n          this._makeTreeHash(childrenData, node);\n        },\n        this\n      );\n\n      return ids;\n    },\n\n    /**\n     * Create node\n     * @param {object} nodeData - Datum of node\n     * @param {string} parentId - Parent id\n     * @returns {TreeNode} TreeNode\n     */\n    _createNode: function(nodeData, parentId) {\n      nodeData = extend(\n        {\n          state: this.nodeDefaultState\n        },\n        nodeData\n      );\n\n      return new TreeNode(nodeData, parentId);\n    },\n\n    /**\n     * Get children\n     * @param {string} nodeId - Node id\n     * @returns {?Array.<TreeNode>} children\n     */\n    getChildren: function(nodeId) {\n      var childIds = this.getChildIds(nodeId);\n\n      if (!childIds) {\n        return null;\n      }\n\n      return map(\n        childIds,\n        function(childId) {\n          return this.getNode(childId);\n        },\n        this\n      );\n    },\n\n    /**\n     * Get child ids\n     * @param {string} nodeId - Node id\n     * @returns {?Array.<string>} Child ids\n     */\n    getChildIds: function(nodeId) {\n      var node = this.getNode(nodeId);\n\n      if (!node) {\n        return null;\n      }\n\n      return node.getChildIds();\n    },\n\n    /**\n     * Get the number of nodes\n     * @returns {number} The number of nodes\n     */\n    getCount: function() {\n      return keys(this.treeHash).length;\n    },\n\n    /**\n     * Get last depth\n     * @returns {number} The last depth\n     */\n    getLastDepth: function() {\n      var depths = map(\n        this.treeHash,\n        function(node) {\n          return this.getDepth(node.getId());\n        },\n        this\n      );\n\n      return Math.max.apply(null, depths);\n    },\n\n    /**\n     * Find node\n     * @param {string} id - A node id to find\n     * @returns {?TreeNode} Node\n     */\n    getNode: function(id) {\n      return this.treeHash[id];\n    },\n\n    /**\n     * Get depth from node id\n     * @param {string} id - A node id to find\n     * @returns {?number} Depth\n     */\n    getDepth: function(id) {\n      var node = this.getNode(id),\n        depth = 0,\n        parent;\n\n      if (!node) {\n        return null;\n      }\n\n      parent = this.getNode(node.getParentId());\n      while (parent) {\n        depth += 1;\n        parent = this.getNode(parent.getParentId());\n      }\n\n      return depth;\n    },\n\n    /**\n     * Return parent id of node\n     * @param {string} id - Node id\n     * @returns {?string} Parent id\n     */\n    getParentId: function(id) {\n      var node = this.getNode(id);\n\n      if (!node) {\n        return null;\n      }\n\n      return node.getParentId();\n    },\n    /**\n     * Return parents ids of node\n     * @param {string} id - Node id\n     * @returns {Array.<string>} Parents node ids\n     */\n    getParentIds: function(id) {\n      var parentsNodeList = [];\n      var node = this.getNode(id);\n      var parentNodeId = node.getParentId();\n\n      while (parentNodeId) {\n        node = this.getNode(parentNodeId);\n        parentNodeId = node.getParentId();\n        parentsNodeList.push(node);\n      }\n\n      return map(parentsNodeList, function(parentsNode) {\n        return parentsNode.getId();\n      });\n    },\n    /**\n     * Remove a node with children.\n     * - The update event will be fired with parent node.\n     * @param {string} id - Node id to remove\n     * @param {boolean} [isSilent] - If true, it doesn't trigger the 'update' event\n     */\n    remove: function(id, isSilent) {\n      var node = this.getNode(id),\n        parent;\n\n      if (!node) {\n        return;\n      }\n\n      parent = this.getNode(node.getParentId());\n\n      forEach(\n        node.getChildIds(),\n        function(childId) {\n          this.remove(childId, true);\n        },\n        this\n      );\n\n      parent.removeChildId(id);\n      delete this.treeHash[id];\n\n      if (!isSilent) {\n        this.fire('update', parent.getId());\n      }\n    },\n\n    /**\n     * Add node(s).\n     * - If the parentId is falsy, the node will be appended to rootNode.\n     * - The update event will be fired with parent node.\n     * @param {Array|object} data - Raw-data\n     * @param {string} parentId - Parent id\n     * @param {boolean} [isSilent] - If true, it doesn't trigger the 'update' event\n     * @returns {Array.<string>} New added node ids\n     */\n    add: function(data, parentId, isSilent) {\n      var parent = this.getNode(parentId) || this.rootNode,\n        ids;\n\n      data = [].concat(data);\n      ids = this._makeTreeHash(data, parent);\n\n      if (!isSilent) {\n        this.fire('update', parent.getId());\n      }\n\n      return ids;\n    },\n\n    /**\n     * Set data properties of a node\n     * @param {string} id - Node id\n     * @param {object} props - Properties\n     * @param {boolean} [isSilent] - If true, it doesn't trigger the 'update' event\n     */\n    setNodeData: function(id, props, isSilent) {\n      var node = this.getNode(id);\n\n      if (!node || !props) {\n        return;\n      }\n\n      node.setData(props);\n\n      if (!isSilent) {\n        this.fire('update', id);\n      }\n    },\n\n    /**\n     * Remove node data\n     * @param {string} id - Node id\n     * @param {string|Array} names - Names of properties\n     * @param {boolean} [isSilent] - If true, it doesn't trigger the 'update' event\n     */\n    removeNodeData: function(id, names, isSilent) {\n      var node = this.getNode(id);\n\n      if (!node || !names) {\n        return;\n      }\n\n      if (snippet.isArray(names)) {\n        node.removeData.apply(node, names);\n      } else {\n        node.removeData(names);\n      }\n\n      if (!isSilent) {\n        this.fire('update', id);\n      }\n    },\n\n    /**\n     * Move a node to new parent's child\n     * @param {string} nodeId - Node id\n     * @param {string} newParentId - New parent id\n     * @param {number} [index] - Start index number for inserting\n     * @param {boolean} [isSilent] - If true, it doesn't trigger the 'update' event\n     */\n    /* eslint-disable complexity*/\n    move: function(nodeId, newParentId, index, isSilent) {\n      var node = this.getNode(nodeId);\n      var originalParentId, newParent, sameParent;\n\n      if (!node) {\n        return;\n      }\n\n      newParent = this.getNode(newParentId) || this.rootNode;\n      newParentId = newParent.getId();\n      originalParentId = node.getParentId();\n      sameParent = index === -1 && originalParentId === newParentId;\n\n      if (nodeId === newParentId || sameParent || this.contains(nodeId, newParentId)) {\n        return;\n      }\n\n      this._changeOrderOfIds(nodeId, newParentId, originalParentId, index);\n\n      if (!isSilent) {\n        this.fire('move', nodeId, originalParentId, newParentId, index);\n      }\n    } /* eslint-enable complexity*/,\n\n    /**\n     * Change order of ids\n     * @param {string} nodeId - Node id\n     * @param {string} newParentId - New parent id\n     * @param {string} originalParentId - Original parent id\n     * @param {number} index - Moving index (When child node is moved on parent node, the value is -1)\n     * @private\n     */\n    _changeOrderOfIds: function(nodeId, newParentId, originalParentId, index) {\n      var node = this.getNode(nodeId);\n      var newParent = this.getNode(newParentId) || this.rootNode;\n      var originalParent = this.getNode(originalParentId);\n      var isSameParentIds = newParentId === originalParentId;\n\n      if (index !== -1) {\n        if (isSameParentIds) {\n          newParent.moveChildId(nodeId, index);\n        } else {\n          newParent.insertChildId(nodeId, index);\n          originalParent.removeChildId(nodeId);\n        }\n      } else if (!isSameParentIds) {\n        newParent.addChildId(nodeId);\n        originalParent.removeChildId(nodeId);\n      }\n\n      node.setParentId(newParentId);\n    },\n\n    /**\n     * Whether a node is a ancestor of another node.\n     * @param {string} containerId - Id of a node that may contain the other node\n     * @param {string} containedId - Id of a node that may be contained by the other node\n     * @returns {boolean} Whether a node contains another node\n     */\n    contains: function(containerId, containedId) {\n      var parentId = this.getParentId(containedId),\n        isContained = false;\n\n      while (!isContained && parentId) {\n        isContained = containerId === parentId;\n        parentId = this.getParentId(parentId);\n      }\n\n      return isContained;\n    },\n\n    /**\n     * Sort nodes\n     * @param {Function} comparator - Comparator function\n     * @param {string} [parentId] - Id of a node to sort partially\n     */\n    sort: function(comparator, parentId) {\n      var iteratee = function(node, nodeId) {\n        var children = this.getChildren(nodeId);\n        var childIds;\n\n        if (children.length > 1) {\n          children.sort(comparator);\n\n          childIds = map(children, function(child) {\n            return child.getId();\n          });\n          node.replaceChildIds(childIds);\n        }\n      };\n      var node;\n\n      if (parentId) {\n        node = this.getNode(parentId);\n        iteratee.call(this, node, parentId);\n      } else {\n        this.eachAll(iteratee, this);\n      }\n    },\n\n    /**\n     * Get node data (all)\n     * @param {string} nodeId - Node id\n     * @returns {?object} Node data\n     */\n    getNodeData: function(nodeId) {\n      var node = this.getNode(nodeId);\n\n      if (!node) {\n        return null;\n      }\n\n      return node.getAllData();\n    },\n\n    /**\n     * Traverse this tree iterating over all nodes.\n     * @param {Function} iteratee - Iteratee function\n     * @param {object} [context] - Context of iteratee\n     */\n    eachAll: function(iteratee, context) {\n      context = context || this;\n\n      forEach(this.treeHash, function() {\n        iteratee.apply(context, arguments);\n      });\n    },\n\n    /**\n     * Traverse this tree iterating over all descendants of a node.\n     * @param {Function} iteratee - Iteratee function\n     * @param {string} parentId - Parent node id\n     * @param {object} [context] - Context of iteratee\n     */\n    each: function(iteratee, parentId, context) {\n      // depth-first\n      var stack, nodeId, node;\n\n      node = this.getNode(parentId);\n      if (!node) {\n        return;\n      }\n      stack = node.getChildIds();\n\n      context = context || this;\n      while (stack.length) {\n        nodeId = stack.pop();\n        node = this.getNode(nodeId);\n        iteratee.call(context, node, nodeId);\n\n        stack = stack.concat(node.getChildIds());\n      }\n    }\n  }\n);\n\nsnippet.CustomEvents.mixin(TreeModel);\nmodule.exports = TreeModel;\n\n\n//# sourceURL=webpack://tui.Tree/./src/js/treeModel.js?");

/***/ }),

/***/ "./src/js/treeNode.js":
/*!****************************!*\
  !*** ./src/js/treeNode.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @fileoverview Control each tree node's data\n * @author NHN. FE dev Lab <dl_javascript@nhn.com>\n */\nvar snippet = __webpack_require__(/*! tui-code-snippet */ \"tui-code-snippet\");\nvar states = __webpack_require__(/*! ./consts/states */ \"./src/js/consts/states.js\").node,\n  util = __webpack_require__(/*! ./util */ \"./src/js/util.js\");\n\nvar lastIndex = 0,\n  getNextIndex = function() {\n    var index = lastIndex;\n    lastIndex += 1;\n\n    return index;\n  },\n  RESERVED_PROPERTIES = {\n    id: '',\n    state: 'setState',\n    children: ''\n  },\n  inArray = snippet.inArray;\n\n/**\n * TreeNode\n * @Class TreeNode\n * @param {Object} nodeData - Node data\n * @param {string} [parentId] - Parent node id\n * @ignore\n */\nvar TreeNode = snippet.defineClass(\n  /** @lends TreeNode.prototype */ {\n    static: {\n      /**\n       * Set prefix of id\n       * @param {string} prefix - Prefix of id\n       */\n      setIdPrefix: function(prefix) {\n        this.idPrefix = prefix || this.idPrefix;\n      },\n\n      /**\n       * Prefix of id\n       * @type {string}\n       */\n      idPrefix: ''\n    },\n    init: function(nodeData, parentId) {\n      /**\n       * Node id\n       * @type {string}\n       * @private\n       */\n      this._id = this.constructor.idPrefix + getNextIndex();\n\n      /**\n       * Parent node id\n       * @type {string}\n       * @private\n       */\n      this._parentId = parentId;\n\n      /**\n       * Id list of children\n       * @type {Array.<number>}\n       * @private\n       */\n      this._childIds = [];\n\n      /**\n       * Node data\n       * @type {object}\n       * @private\n       */\n      this._data = {};\n\n      /**\n       * Node state\n       * @type {string}\n       * @private\n       */\n      this._state = states.CLOSED;\n\n      this.setData(nodeData);\n    },\n\n    /**\n     * Set reserved properties from data\n     * @param {object} data - Node data\n     * @returns {object} Node data\n     * @private\n     */\n    _setReservedProperties: function(data) {\n      snippet.forEachOwnProperties(\n        RESERVED_PROPERTIES,\n        function(setter, name) {\n          var value = data[name];\n\n          if (value && setter) {\n            this[setter](value);\n          }\n          delete data[name];\n        },\n        this\n      );\n\n      return data;\n    },\n\n    /**\n     * Toggle state\n     */\n    toggleState: function() {\n      if (this._state === states.CLOSED) {\n        this._state = states.OPENED;\n      } else {\n        this._state = states.CLOSED;\n      }\n    },\n\n    /**\n     * Set state\n     * @param {string} state - State of node ('closed', 'opened')\n     */\n    setState: function(state) {\n      state = String(state);\n      this._state = states[state.toUpperCase()] || this._state;\n    },\n\n    /**\n     * Get state\n     * @returns {string} state ('opened' or 'closed')\n     */\n    getState: function() {\n      return this._state;\n    },\n\n    /**\n     * Get id\n     * @returns {string} Node id\n     */\n    getId: function() {\n      return this._id;\n    },\n\n    /**\n     * Get parent id\n     * @returns {string} Parent node id\n     */\n    getParentId: function() {\n      return this._parentId;\n    },\n\n    /**\n     * Set parent id\n     * @param {string} parentId - Parent node id\n     */\n    setParentId: function(parentId) {\n      this._parentId = parentId;\n    },\n\n    /**\n     * Replace childIds\n     * @param {Array.<number>} childIds - Id list of children\n     */\n    replaceChildIds: function(childIds) {\n      this._childIds = childIds;\n    },\n\n    /**\n     * Get id list of children\n     * @returns {Array.<number>} Id list of children\n     */\n    getChildIds: function() {\n      return this._childIds.slice();\n    },\n\n    /**\n     * Add child id\n     * @param {string} id - Child node id\n     */\n    addChildId: function(id) {\n      var childIds = this._childIds;\n\n      if (snippet.inArray(childIds, id) === -1) {\n        childIds.push(id);\n      }\n    },\n\n    /**\n     * Remove child id\n     * @param {string} id - Child node id\n     */\n    removeChildId: function(id) {\n      util.removeItemFromArray(id, this._childIds);\n    },\n\n    /**\n     * Get data\n     * @param {string} name - Property name of data\n     * @returns {*} Data\n     */\n    getData: function(name) {\n      return this._data[name];\n    },\n\n    /**\n     * Get all data\n     * @returns {Object} Data\n     */\n    getAllData: function() {\n      return snippet.extend({}, this._data);\n    },\n\n    /**\n     * Set data\n     * @param {Object} data - Data for adding\n     */\n    setData: function(data) {\n      data = this._setReservedProperties(data);\n      snippet.extend(this._data, data);\n    },\n\n    /**\n     * Remove data\n     * @param {...string} names - Names of data\n     */\n    removeData: function() {\n      snippet.forEachArray(\n        arguments,\n        function(name) {\n          delete this._data[name];\n        },\n        this\n      );\n    },\n\n    /**\n     * Return true if this node has a provided child id.\n     * @param {string} id - Node id\n     * @returns {boolean} - Whether this node has a provided child id.\n     */\n    hasChild: function(id) {\n      return inArray(id, this._childIds) !== -1;\n    },\n\n    /**\n     * Return whether this node is leaf.\n     * @returns {boolean} Node is leaf or not.\n     */\n    isLeaf: function() {\n      return !this._childIds.length && !this.getData('hasChild');\n    },\n\n    /**\n     * Return whether this node is root.\n     * @returns {boolean} Node is root or not.\n     */\n    isRoot: function() {\n      return snippet.isFalsy(this._parentId);\n    },\n\n    /**\n     * Get index of child\n     * @param {string} id - Node id\n     * @returns {number} Index of child in children list\n     */\n    getChildIndex: function(id) {\n      return inArray(id, this._childIds);\n    },\n\n    /**\n     * Insert child id\n     * @param {string} id - Child node id\n     * @param {number} index - Index number of insert position\n     */\n    insertChildId: function(id, index) {\n      var childIds = this._childIds;\n\n      if (inArray(id, childIds) === -1) {\n        childIds.splice(index, 0, id);\n      }\n    },\n\n    /**\n     * Move child id\n     * @param {string} id - Child node id\n     * @param {number} index - Index number of insert position\n     */\n    moveChildId: function(id, index) {\n      var childIds = this._childIds;\n      var originIdx = this.getChildIndex(id);\n\n      if (inArray(id, childIds) !== -1) {\n        if (originIdx < index) {\n          index -= 1;\n        }\n\n        childIds.splice(index, 0, childIds.splice(originIdx, 1)[0]);\n      }\n    }\n  }\n);\nmodule.exports = TreeNode;\n\n\n//# sourceURL=webpack://tui.Tree/./src/js/treeNode.js?");

/***/ }),

/***/ "./src/js/util.js":
/*!************************!*\
  !*** ./src/js/util.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @fileoverview Helper object to make easy tree elements\n * @author NHN. FE dev Lab <dl_javascript@nhn.com>\n */\nvar snippet = __webpack_require__(/*! tui-code-snippet */ \"tui-code-snippet\");\nvar isUndefined = snippet.isUndefined,\n  pick = snippet.pick,\n  templateMaskRe = /\\{\\{(.+?)}}/gi,\n  isValidDotNotationRe = /^\\w+(?:\\.\\w+)*$/,\n  isValidDotNotation = function(str) {\n    return isValidDotNotationRe.test(str);\n  },\n  isArray = snippet.isArraySafe,\n  forEach = snippet.forEach,\n  browser = snippet.browser,\n  isSupportPageOffset = typeof window.pageXOffset !== 'undefined',\n  isCSS1Compat = document.compatMode === 'CSS1Compat',\n  isOlderIE = browser.msie && browser.version < 9,\n  hostnameSent = false;\n\n/**\n * @ignore\n */\nvar util = {\n  /**\n   * Remove first specified item from array, if it exists\n   * @param {*} item Item to look for\n   * @param {Array} arr Array to query\n   */\n  removeItemFromArray: function(item, arr) {\n    var index = arr.length - 1;\n\n    while (index > -1) {\n      if (item === arr[index]) {\n        arr.splice(index, 1);\n      }\n      index -= 1;\n    }\n  },\n\n  /**\n   * Add classname\n   * @param {HTMLElement} element - Target element\n   * @param {string} className - Classname\n   */\n  addClass: function(element, className) {\n    if (!element) {\n      return;\n    }\n\n    if (element.className === '') {\n      element.className = className;\n    } else if (!util.hasClass(element, className)) {\n      element.className += ' ' + className;\n    }\n  },\n\n  /**\n   * Remove classname\n   * @param {HTMLElement} element - Target element\n   * @param {string} className - Classname\n   */\n  removeClass: function(element, className) {\n    var originalClassName = util.getClass(element),\n      arr,\n      index;\n\n    if (!originalClassName) {\n      return;\n    }\n\n    arr = originalClassName.split(' ');\n    index = snippet.inArray(className, arr);\n    if (index !== -1) {\n      arr.splice(index, 1);\n      element.className = arr.join(' ');\n    }\n  },\n\n  /**\n   * Add event to element\n   * @param {Object} element A target element\n   * @param {String} eventName A name of event\n   * @param {Function} handler A callback function to add\n   */\n  addEventListener: function(element, eventName, handler) {\n    if (element.addEventListener) {\n      element.addEventListener(eventName, handler, false);\n    } else {\n      element.attachEvent('on' + eventName, handler);\n    }\n  },\n\n  /**\n   * Remove event from element\n   * @param {Object} element A target element\n   * @param {String} eventName A name of event\n   * @param {Function} handler A callback function to remove\n   */\n  removeEventListener: function(element, eventName, handler) {\n    if (element.removeEventListener) {\n      element.removeEventListener(eventName, handler, false);\n    } else {\n      element.detachEvent('on' + eventName, handler);\n    }\n  },\n\n  /**\n   * Get target element\n   * @param {Event} e Event object\n   * @returns {HTMLElement} Event target\n   */\n  getTarget: function(e) {\n    var target;\n    e = e || window.event;\n    target = e.target || e.srcElement;\n\n    return target;\n  },\n\n  /**\n   * Get key code from event object\n   * @param {Event} e Event object\n   * @returns {Number} KeyCode\n   */\n  getKeyCode: function(e) {\n    e = e || window.event;\n\n    return e.which || e.keyCode;\n  },\n\n  /**\n   * Get class name\n   * @param {HTMLElement} element HTMLElement\n   * @returns {string} Class name\n   */\n  getClass: function(element) {\n    return (\n      element &&\n      element.getAttribute &&\n      (element.getAttribute('class') || element.getAttribute('className') || '')\n    );\n  },\n\n  /**\n   * Check the element has specific class or not\n   * @param {HTMLElement} element A target element\n   * @param {string} className A name of class to find\n   * @returns {boolean} Whether the element has the class\n   */\n  hasClass: function(element, className) {\n    var elClassName = util.getClass(element);\n\n    return elClassName.indexOf(className) > -1;\n  },\n\n  /**\n   * Find element by class name\n   * @param {HTMLElement} target A target element\n   * @param {string} className A name of class\n   * @returns {Array.<HTMLElement>} Elements\n   */\n  getElementsByClassName: function(target, className) {\n    var all, filtered;\n\n    if (target.querySelectorAll) {\n      filtered = target.querySelectorAll('.' + className);\n    } else {\n      all = snippet.toArray(target.getElementsByTagName('*'));\n      filtered = snippet.filter(all, function(el) {\n        var classNames = el.className || '';\n\n        return classNames.indexOf(className) !== -1;\n      });\n    }\n\n    if (!filtered) {\n      filtered = [];\n    }\n\n    return filtered;\n  },\n\n  /**\n   * Find element by class name among child nodes\n   * @param {HTMLElement} target A target element\n   * @param {string} className A name of class\n   * @returns {Array.<HTMLElement>} Elements\n   */\n  getChildElementByClassName: function(target, className) {\n    var children = target.childNodes;\n    var i = 0;\n    var length = children.length;\n    var child;\n\n    for (; i < length; i += 1) {\n      child = children[i];\n      if (util.hasClass(child, className)) {\n        return child;\n      }\n    }\n\n    return null;\n  },\n\n  /**\n   * Check whether the click event by right button\n   * @param {MouseEvent} event Event object\n   * @returns {boolean} Whether the click event by right button\n   */\n  isRightButton: function(event) {\n    return util._getButton(event) === 2;\n  },\n\n  /**\n   * Whether the property exist or not\n   * @param {Array} props A property\n   * @returns {string|boolean} Property name or false\n   * @example\n   * var userSelectProperty = util.testProp([\n   *     'userSelect',\n   *     'WebkitUserSelect',\n   *     'OUserSelect',\n   *     'MozUserSelect',\n   *     'msUserSelect'\n   * ]);\n   */\n  testProp: function(props) {\n    var style = document.documentElement.style,\n      propertyName = false;\n\n    /* eslint-disable consistent-return */\n    snippet.forEach(props, function(prop) {\n      if (prop in style) {\n        propertyName = prop;\n\n        return false;\n      }\n    });\n    /* eslint-enable consistent-return */\n\n    return propertyName;\n  },\n\n  /**\n   * Prevent default event\n   * @param {Event} event Event object\n   */\n  preventDefault: function(event) {\n    if (event.preventDefault) {\n      event.preventDefault();\n    } else {\n      event.returnValue = false;\n    }\n  },\n\n  /**\n   * Make html from template\n   * @param {string} source - Template html\n   * @param {Object} props - Template data\n   * @returns {string} html\n   */\n  renderTemplate: function(source, props) {\n    /* eslint-disable require-jsdoc */\n    function pickValue(names) {\n      return pick.apply(null, [props].concat(names));\n    }\n    /* eslint-enable require-jsdoc */\n\n    return source.replace(templateMaskRe, function(match, name) {\n      var value;\n\n      if (isValidDotNotation(name)) {\n        value = pickValue(name.split('.'));\n      }\n\n      if (isArray(value)) {\n        value = value.join(' ');\n      } else if (isUndefined(value)) {\n        value = '';\n      }\n\n      return value;\n    });\n  },\n\n  /**\n   * Normalization for event button property\n   * 0: First mouse button, 2: Second mouse button, 1: Center button\n   * @param {MouseEvent} event Event object\n   * @returns {?number} button type\n   * @private\n   */\n  _getButton: function(event) {\n    var primary = '0,1,3,5,7';\n    var secondary = '2,6';\n    var wheel = '4';\n    var result = null;\n    var button;\n\n    if (document.implementation.hasFeature('MouseEvents', '2.0')) {\n      return event.button;\n    }\n\n    button = String(event.button);\n    if (primary.indexOf(button) > -1) {\n      result = 0;\n    } else if (secondary.indexOf(button) > -1) {\n      result = 2;\n    } else if (wheel.indexOf(button) > -1) {\n      result = 1;\n    }\n\n    return result;\n  },\n\n  /**\n   * Get mouse position\n   * @param {MouseEvet} event - Event object\n   * @returns {object} X, Y position of mouse\n   */\n  getMousePos: function(event) {\n    return {\n      x: event.clientX,\n      y: event.clientY\n    };\n  },\n\n  /**\n   * Get value of scroll top on document.body (cross browsing)\n   * @returns {number} Value of scroll top\n   */\n  getWindowScrollTop: function() {\n    var scrollTop;\n\n    if (isSupportPageOffset) {\n      scrollTop = window.pageYOffset;\n    } else {\n      scrollTop = isCSS1Compat ? document.documentElement.scrollTop : document.body.scrollTop;\n    }\n\n    return scrollTop;\n  },\n\n  /**\n   * Get top position value of element\n   * @param {HTMLElement} element - Target element\n   * @returns {number} Top position value\n   */\n  getElementTop: function(element) {\n    var actualTop = 0;\n    var scrollTop;\n\n    while (element) {\n      if (element.tagName.toLowerCase === 'body') {\n        scrollTop = util.getWindowScrollTop();\n      } else {\n        scrollTop = element.scrollTop;\n      }\n\n      actualTop += element.offsetTop - scrollTop + element.clientTop;\n      element = element.offsetParent;\n    }\n\n    return actualTop;\n  },\n\n  /**\n   * Get first text node in target element\n   * @param {HTMLElement} element - Target element to find\n   * @returns {HTMLElement} Text node\n   */\n  getFirstTextNode: function(element) {\n    var childElements = snippet.toArray(element.childNodes);\n    var firstTextNode = '';\n\n    forEach(childElements, function(childElement) {\n      if (childElement.nodeName === '#text') {\n        firstTextNode = childElement;\n\n        return false;\n      }\n\n      return true;\n    });\n\n    return firstTextNode;\n  },\n\n  /**\n   * Remove element from parent element\n   * @param {HTMLElement} element - Target element to remove\n   */\n  removeElement: function(element) {\n    if (element && element.parentNode) {\n      element.parentNode.removeChild(element);\n    }\n  },\n\n  /**\n   * Get change event name as browser\n   * @returns {string} Event name\n   */\n  getChangeEventName: function() {\n    var changeEventName;\n\n    if (isOlderIE) {\n      changeEventName = 'propertychange';\n    } else {\n      changeEventName = 'change';\n    }\n\n    return changeEventName;\n  },\n\n  /**\n   * send hostname\n   */\n  sendHostName: function() {\n    if (hostnameSent) {\n      return;\n    }\n    hostnameSent = true;\n\n    snippet.sendHostname('tree', 'UA-129987462-1');\n  }\n};\n\nmodule.exports = util;\n\n\n//# sourceURL=webpack://tui.Tree/./src/js/util.js?");

/***/ }),

/***/ "tui-code-snippet":
/*!******************************************************************************************************************************!*\
  !*** external {"commonjs":"tui-code-snippet","commonjs2":"tui-code-snippet","amd":"tui-code-snippet","root":["tui","util"]} ***!
  \******************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_tui_code_snippet__;\n\n//# sourceURL=webpack://tui.Tree/external_%7B%22commonjs%22:%22tui-code-snippet%22,%22commonjs2%22:%22tui-code-snippet%22,%22amd%22:%22tui-code-snippet%22,%22root%22:%5B%22tui%22,%22util%22%5D%7D?");

/***/ }),

/***/ "tui-context-menu":
/*!*************************************************************************************************************************************!*\
  !*** external {"commonjs":"tui-context-menu","commonjs2":"tui-context-menu","amd":"tui-context-menu","root":["tui","ContextMenu"]} ***!
  \*************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_tui_context_menu__;\n\n//# sourceURL=webpack://tui.Tree/external_%7B%22commonjs%22:%22tui-context-menu%22,%22commonjs2%22:%22tui-context-menu%22,%22amd%22:%22tui-context-menu%22,%22root%22:%5B%22tui%22,%22ContextMenu%22%5D%7D?");

/***/ })

/******/ });
});