tui.util.defineNamespace("fedoc.content", {});
fedoc.content["treeModel.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Update view and control tree data\n * @author NHN Ent. FE dev team.&lt;dl_javascript@nhnent.com>\n */\n'use strict';\n\nvar TreeNode = require('./treeNode');\n\nvar extend = tui.util.extend,\n    keys = tui.util.keys,\n    forEach = tui.util.forEach,\n    map = tui.util.map;\n\n/**\n * Tree model\n * @constructor TreeModel\n * @param {Array} data - Data\n * @param {Object} options - Options for defaultState and nodeIdPrefix\n **/\nvar TreeModel = tui.util.defineClass(/** @lends TreeModel.prototype */{ /* eslint-disable */\n    init: function(data, options) {/*eslint-enable*/\n        TreeNode.setIdPrefix(options.nodeIdPrefix);\n\n        /**\n         * Default state of node\n         * @type {String}\n         */\n        this.nodeDefaultState = options.nodeDefaultState;\n\n        /**\n         * Root node\n         * @type {TreeNode}\n         */\n        this.rootNode = new TreeNode({\n            state: 'opened'\n        }, null);\n\n        /**\n         * Tree hash having all nodes\n         * @type {object.&lt;string, TreeNode>}\n         */\n        this.treeHash = {};\n\n        this._setData(data);\n    },\n\n    /**\n     * Return prefix of node id\n     * @returns {string} Prefix\n     */\n    getNodeIdPrefix: function() {\n        return TreeNode.idPrefix;\n    },\n\n    /**\n     * Set model with tree data\n     * @param {Array} data - Tree data\n     */\n    _setData: function(data) {\n        var root = this.rootNode,\n            rootId = root.getId();\n\n        this.treeHash[rootId] = root;\n        this._makeTreeHash(data, root);\n    },\n\n    /**\n     * Make tree hash from data and parentNode\n     * @param {Array} data - Tree data\n     * @param {TreeNode} parent - Parent node id\n     * @returns {Array.&lt;string>} Added node ids\n     * @private\n     */\n    _makeTreeHash: function(data, parent) {\n        var parentId = parent.getId(),\n            ids = [];\n\n        forEach(data, function(datum) {\n            var childrenData = datum.children,\n                node = this._createNode(datum, parentId),\n                nodeId = node.getId();\n\n            ids.push(nodeId);\n            this.treeHash[nodeId] = node;\n            parent.addChildId(nodeId);\n            this._makeTreeHash(childrenData, node);\n        }, this);\n\n        return ids;\n    },\n\n    /**\n     * Create node\n     * @param {object} nodeData - Datum of node\n     * @param {string} parentId - Parent id\n     * @returns {TreeNode} TreeNode\n     */\n    _createNode: function(nodeData, parentId) {\n        nodeData = extend({\n            state: this.nodeDefaultState\n        }, nodeData);\n\n        return new TreeNode(nodeData, parentId);\n    },\n\n    /**\n     * Get children\n     * @param {string} nodeId - Node id\n     * @returns {?Array.&lt;TreeNode>} children\n     */\n    getChildren: function(nodeId) {\n        var childIds = this.getChildIds(nodeId);\n\n        if (!childIds) {\n            return null;\n        }\n\n        return map(childIds, function(childId) {\n            return this.getNode(childId);\n        }, this);\n    },\n\n    /**\n     * Get child ids\n     * @param {string} nodeId - Node id\n     * @returns {?Array.&lt;string>} Child ids\n     */\n    getChildIds: function(nodeId) {\n        var node = this.getNode(nodeId);\n\n        if (!node) {\n            return null;\n        }\n\n        return node.getChildIds();\n    },\n\n    /**\n     * Get the number of nodes\n     * @returns {number} The number of nodes\n     */\n    getCount: function() {\n        return keys(this.treeHash).length;\n    },\n\n    /**\n     * Get last depth\n     * @returns {number} The last depth\n     */\n    getLastDepth: function() {\n        var depths = map(this.treeHash, function(node) {\n            return this.getDepth(node.getId());\n        }, this);\n\n        return Math.max.apply(null, depths);\n    },\n\n    /**\n     * Find node\n     * @param {string} id - A node id to find\n     * @returns {?TreeNode} Node\n     */\n    getNode: function(id) {\n        return this.treeHash[id];\n    },\n\n    /**\n     * Get depth from node id\n     * @param {string} id - A node id to find\n     * @returns {?number} Depth\n     */\n    getDepth: function(id) {\n        var node = this.getNode(id),\n            depth = 0,\n            parent;\n\n        if (!node) {\n            return null;\n        }\n\n        parent = this.getNode(node.getParentId());\n        while (parent) {\n            depth += 1;\n            parent = this.getNode(parent.getParentId());\n        }\n\n        return depth;\n    },\n\n    /**\n     * Return parent id of node\n     * @param {string} id - Node id\n     * @returns {?string} Parent id\n     */\n    getParentId: function(id) {\n        var node = this.getNode(id);\n\n        if (!node) {\n            return null;\n        }\n\n        return node.getParentId();\n    },\n\n    /**\n     * Remove a node with children.\n     * - The update event will be fired with parent node.\n     * @param {string} id - Node id to remove\n     * @param {boolean} [isSilent] - If true, it doesn't trigger the 'update' event\n     */\n    remove: function(id, isSilent) {\n        var node = this.getNode(id),\n            parent;\n\n        if (!node) {\n            return;\n        }\n\n        parent = this.getNode(node.getParentId());\n\n        forEach(node.getChildIds(), function(childId) {\n            this.remove(childId, true);\n        }, this);\n\n        parent.removeChildId(id);\n        delete this.treeHash[id];\n\n        if (!isSilent) {\n            this.fire('update', parent.getId());\n        }\n    },\n\n    /**\n     * Add node(s).\n     * - If the parentId is falsy, the node will be appended to rootNode.\n     * - The update event will be fired with parent node.\n     * @param {Array|object} data - Raw-data\n     * @param {string} parentId - Parent id\n     * @param {boolean} [isSilent] - If true, it doesn't trigger the 'update' event\n     * @returns {Array.&lt;string>} New added node ids\n     */\n    add: function(data, parentId, isSilent) {\n        var parent = this.getNode(parentId) || this.rootNode,\n            ids;\n\n        data = [].concat(data);\n        ids = this._makeTreeHash(data, parent);\n\n        if (!isSilent) {\n            this.fire('update', parent.getId());\n        }\n\n        return ids;\n    },\n\n    /**\n     * Set data properties of a node\n     * @param {string} id - Node id\n     * @param {object} props - Properties\n     * @param {boolean} [isSilent] - If true, it doesn't trigger the 'update' event\n     */\n    setNodeData: function(id, props, isSilent) {\n        var node = this.getNode(id);\n\n        if (!node || !props) {\n            return;\n        }\n\n        node.setData(props);\n\n        if (!isSilent) {\n            this.fire('update', id);\n        }\n    },\n\n    /**\n     * Remove node data\n     * @param {string} id - Node id\n     * @param {string|Array} names - Names of properties\n     * @param {boolean} [isSilent] - If true, it doesn't trigger the 'update' event\n     */\n    removeNodeData: function(id, names, isSilent) {\n        var node = this.getNode(id);\n\n        if (!node || !names) {\n            return;\n        }\n\n        if (tui.util.isArray(names)) {\n            node.removeData.apply(node, names);\n        } else {\n            node.removeData(names);\n        }\n\n        if (!isSilent) {\n            this.fire('update', id);\n        }\n    },\n\n    /**\n     * Move a node to new parent's child\n     * @param {string} nodeId - Node id\n     * @param {string} newParentId - New parent id\n     * @param {boolean} [isSilent] - If true, it doesn't trigger the 'update' event\n     */\n    move: function(nodeId, newParentId, isSilent) {\n        var node = this.getNode(nodeId),\n            originalParent, originalParentId, newParent;\n\n        if (!node) {\n            return;\n        }\n        newParent = this.getNode(newParentId) || this.rootNode;\n        newParentId = newParent.getId();\n        originalParentId = node.getParentId();\n        originalParent = this.getNode(originalParentId);\n\n        if (nodeId === newParentId || this.contains(nodeId, newParentId)) {\n            return;\n        }\n        originalParent.removeChildId(nodeId);\n        node.setParentId(newParentId);\n        newParent.addChildId(nodeId);\n\n        if (!isSilent) {\n            this.fire('move', nodeId, originalParentId, newParentId);\n        }\n    },\n\n    /**\n     * Whether a node is a ancestor of another node.\n     * @param {string} containerId - Id of a node that may contain the other node\n     * @param {string} containedId - Id of a node that may be contained by the other node\n     * @returns {boolean} Whether a node contains another node\n     */\n    contains: function(containerId, containedId) {\n        var parentId = this.getParentId(containedId),\n            isContained = false;\n\n        while (!isContained &amp;&amp; parentId) {\n            isContained = (containerId === parentId);\n            parentId = this.getParentId(parentId);\n        }\n\n        return isContained;\n    },\n\n    /**\n     * Sort nodes\n     * @param {Function} comparator - Comparator function\n     */\n    sort: function(comparator) {\n        this.eachAll(function(node, nodeId) {\n            var children = this.getChildren(nodeId),\n                childIds;\n\n            if (children.length > 1) {\n                children.sort(comparator);\n\n                childIds = map(children, function(child) {\n                    return child.getId();\n                });\n                node.replaceChildIds(childIds);\n            }\n        });\n    },\n\n    /**\n     * Get node data (all)\n     * @param {string} nodeId - Node id\n     * @returns {?object} Node data\n     */\n    getNodeData: function(nodeId) {\n        var node = this.getNode(nodeId);\n\n        if (!node) {\n            return null;\n        }\n\n        return node.getAllData();\n    },\n\n    /**\n     * Traverse this tree iterating over all nodes.\n     * @param {Function} iteratee - Iteratee function\n     * @param {object} [context] - Context of iteratee\n     */\n    eachAll: function(iteratee, context) {\n        context = context || this;\n\n        forEach(this.treeHash, function() {\n            iteratee.apply(context, arguments);\n        });\n    },\n\n    /**\n     * Traverse this tree iterating over all descendants of a node.\n     * @param {Function} iteratee - Iteratee function\n     * @param {string} parentId - Parent node id\n     * @param {object} [context] - Context of iteratee\n     */\n    each: function(iteratee, parentId, context) { //depth-first\n        var stack, nodeId, node;\n\n        node = this.getNode(parentId);\n        if (!node) {\n            return;\n        }\n        stack = node.getChildIds();\n\n        context = context || this;\n        while (stack.length) {\n            nodeId = stack.pop();\n            node = this.getNode(nodeId);\n            iteratee.call(context, node, nodeId);\n\n            stack = stack.concat(node.getChildIds());\n        }\n    }\n});\n\ntui.util.CustomEvents.mixin(TreeModel);\nmodule.exports = TreeModel;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"